# 3. 소프트웨어 개발 보안 구축

## 179) Secure SDLC (A)

: 보안상 안전한 소프트웨어를 개발하기 위해 SDLC에 보안 강화를 위한 프로세스를 포함한 것을 의미

- 소프트웨어 유지 보수 단계에서 보안 이슈를 해결하기위해 소모되는 많은 비용을 최소화하기 위해 등장
- 대표적인 방법론에는 Secure Software 사의 CLASP, Microsoft 사의 SDL이 있다.
- 요구사항 분석, 설계, 구현, 테스트, 유지 보수 등 DLC 전체 단계에 걸쳐 수행되어야 할 보안 활동을 제시



### 요구사항 분석 단계에서의 보안 활동

: 보안 항목에 해당하느 ㄴ요구사항을 식별하는 작업을 수행

- 전산화되는 정보가 가지고 있는 보안 수준을 보안 요소별로 등급을 구분하여 분류
- 조직의 정보 관련 보안 정책을 참고하여 개발에 적용할 수 있는 보안 정책 항목들의 출처, 요구 수준, 세부 내용 등을 문서화
- 보안 요소
  - 기밀성
    - 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용
    - 정보가 전송 중에 노출되더라도 데이터를 읽을 수 없다.
  - 무결성
    - 시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있다.
  - 가용성
    - 인가받은 사용자는 언제라도 사용할 수 있다.
  - 인증
    - 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위
    - 대표적인 방법으로 패스워드, 인증용 카드, 지문 검사 등이 있다.
  - 부인 방지
    - 데이터를 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거를 제공



### 설계 단계에서의 보안 활동

: 식별된 보안 요구사항들을 소프트웨어 설계서에 반영하고, 보안 설계서를 작성

- 발생할 수 있는 위협을 식별하여 보안대책, 소요예산, 사고 발생 시 영향 범위와 대응책 등을 수립
- 네트워크, 서버, 물리적 보안, 개발 프로그램 등 환경에 대한 보안통제 기준을 수립하여 설계에 반영
  - 네트워크 : 외부의 사이버 공격으로부터 개발 환경을 보호하기 위해 네트워크를 분리하거나 방화벽을 설치
  - 서버 : 보안이 뛰어난 운영체제를 사용하고 보안 업데이트, 외부접속에 대한 접근 통제 등을 실시
  - 물리적 보안 : 출입통제, 개발 공간 제한, 폐쇄회로 등의 감시설비를 설치
  - 개발 프로그램 : 허가되지 않은 프로그램을 통제하고 지속적인 데이터 무결성 검사를 실시



### 구현 단계에서의 보안 활동

: 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수하며, 설계서에 따라 보안 요구사항들을 구현

- 개발 과정 중에는 지속적인 단위 테스트를 통해 소프트웨어에 발생할 수 있는 보안 취약점을 최소화해야 한다.

- 코드 점검 및 소스 코드 진단 작업을 통해 소스 코드의 안정성을 확보해야 한다.

- 시큐어 코딩(Secure Coding)

  : 구현 단계에서 발생할 수 있는 보안 취약점을 최소화하기 위한 보안 요소들을 고려하여 코딩하는 것

  - 보안 취약점을 사전에 대응하여 안정성과 신뢰성을 확보하기 위해 사용
  - 보안 정책을 바탕으로 시큐어 코딩 가이드를 작성하고, 개발자에게는 시큐어 코딩 교육을 실시



### 테스트 단계에서의 보안 활동

: 설계 단계에서 작성한 보안 설계서를 바탕으로 보안 사항들이 정확히 반영되고 동작되는지 점검

- 동적 분석 도구 또는 모의 침투테스트를 통해 설계 단계에서 식별된 위협들의 해결여부를 검증
- 설계 단계에서 식별된 위협들 외에도 구현단계에서 추가로 제시된 위협들과 취약점들을 점검할 수 있도록 테스트 계획을 수립하고 시행
- 테스트 단계에서 수행한 모든 결과는 문서화하여 보존하고, 개발자에게 피드백 되어야 한다.



### 유지보수 단계에서의 보안 활동

: 이전 과정을 모두 수행하였음에도 발생할 수 있는 보안사고들을 식별하고, 사고 발생 시 이를 해결하고 보안 패치를 실행



## 180) 세션 통제(B)

: 세션은 서버와 클라이언트의 연결을 의미하고, 세션 통제는 세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것을 의미

- 소프트웨어 개발 과정 중 <b>요구사항 분석 및 설계 단계</b>에서 진단해야하는 보안 점검 내용
- 세션 통제의 보안 약점에는 불충분한 세션 관리, 잘못된 세션에 의한 정보 노출이 있다.



#### 불충분한 세션 관리

: 일정한 규칙이 존재하는 세션 ID가 발급되거나 타임아웃이 너무 길게 설정되어 있는 경우 발생할 수 있는 보안 약점

- 세션 관리가 충분하지 않으면 침입자는 세션 하이재킹과 같은 공격을 통해 획득한 세션 ID로 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근할 수 있다.
  - 세션 하이재킹 : 서버에 접속하고 있는 클라이언트들의 세션 정보를 가로채는 공격 기법



### 잘못된 세션에 의한 정보 노출

: 다중 스레드(Multi-Thread) 환경에서 멤버 변수에 정보를 저장할 떄 발생하는 보안 약점

- 다중 스레드

  : 프로세스 내의 작업 단위로 시스템의 자원을 할당받아 실행하는 프로그램 단위 두개 이상의 스레드가 생성되어 동시 처리되는 다중 작업

- 멤버 변수

  : 객체와 연결된 변수로, 클래스 내에 선언되어 클래스의 모든 메소드들이 접근 가능한 변수

- 싱글톤 패턴에서 발새하는 레이스컨디션으로 인해 동기화 오류가 발생하거나, 멤버 변수의 정보가 노출

  - 싱글톤 : 하나의 객체를 생성하면 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없는 디자인 패턴
  - 레이스컨디션 : 두 개 이상의 프로세스가 공용 자원을 획득하기 위해 경쟁하는 상태

- 멤버 변수 보다 지역 변수를 활용하여 변수의 범위를 제한함으로써 방지할 수 있다.



### 세션 설계시 고려 사항

- 모든 페이지에서 로그아웃이 가능하도록 UI를 구성
- 로그아웃 요청 시 할당된 세션이 완전히 제거되도록 한다.
- 세션 타임아웃은 중요도가 높으면 2~5분, 낮으면 15~30분으로 설정
- 이전 세션이 종료되지 않으면 새 세션이 생성되지 못하도록 설계
- 중복 로그인을 허용하지 않은 경우 클라이언트의 중복 접근에 대한 세션 관리 정책을 수립
- 패스워드 변경 시 활성화된 세션을 삭제하고 재할당



### 세션 ID의 관리 방법

- 안전한 서버에서 최소 128비트의 길이로 생성
- 예측이 불가능하도록 안전한 난수 알고리즘을 적용
- URL Rewrite 기능을 사용하지 않는 방향으로 설계
- 로그인 시 로그인 전의 세션ID를 삭제하고 재할당
- 장기간 접속하고 있는 세션ID는 주기적으로 재할당되도록 설계



## 181) 입력 데이터 검증 및 표현(B)

: 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목

- 소프트웨어 개발의 <b>구현 단계</b>에서 유효성 검증 체계를 갖추고, 검증되지 않은 데이터가 입력되는 경우 이를 처리할 수 있도록 구현해야 한다.
- 입력 데이터를 처리하는 객체에 지정된 자료형이 올바른지 확인하고, 일관된 언어셋을 사용하도록 코딩



### 입력 데이터 검증 및 표현의 보안 약점

: 입력 데이터 검증 및 표현과 관련된 점검을 수행하지 않은 경우 SQL 삽입, 자원 삽입, 크로스사이트 스크립팅, 운영체제 명령어 삽입 등의 공격에 취약해진다.

- SQL 삽입
  - 입력란에 SQL을 삽입하여 무단으로 DB를 조회하거나 조작하는 보안 약점
  - 동적쿼리에 사용되는 입력 데이터에 예약어 및 특수문자가 입력되지 않게 필터링 되도록 설정하여 방지할 수 있다.
- 경로 조작 및 자원 삽입
  - 데이터 입출력 경로를 조작하여 서버 자원을 수정, 삭제할 수 있는 보안 약점
  - 사용자 입력값을 식별자로 사용하는 경우, 경로 순회 공격을 막는 필터를 사용하여 방지할 수 있다.
- 크로스사이트 스크립팅(XSS)
  - 웹페이지에 악의적인 스크립트를 삽입하여 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점
  - HTML 태그의 사용을 제한하거나 스크립트에 삽입되지 않도록 '<', '>', '&' 등의 문자를 다른 문자로 치환함으로써 방지할 수 있다.
- 운영체제 명령어 삽입
  - 외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취하거나 시스템 장애를 유발하는 보안 약점
  - 웹 인터페이스를 통해 시스템 명령어가 전달되지 않도록 하고, 외부 입력값을 검증없이 내부 명령어로 사용하지 않음으로써 방지할 수 있다.
- 위험한 형식 파일 업로드
  - 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로 시스템에 손상을 주거나, 시스템을 제어할 수 있는 보안 약점
  - 업로드 되는 파일의 확장자 제한, 파일명의 암호화, 웹사이트와 파일 서버의 경로 분리, 실행 속성을 제거하는 등의 방법으로 방지할 수 있다.
- 신뢰되지 않는 URL 주소로 자동접속 연결
  - 입력 값으로 사이트 주소를 받는 경우 이를 조작하여 방문자를 피싱 사이트로 유도하는 보안 약점
  - 연결되는 외부 사이트의 주소를 화이트 리스트로 관리함으로써 방지할 수 있다.



## 182) 보안 기능(B)

: 소프트웨어 개발의 <b>구현 단계</b>에서 코딩하는 기능인 인증, 접근제어, 기밀성, 암호화 등을 올바르게 구현하기 위한 보안 점검 항목

- 각 보안 기능들은 서비스 환경이나 취급 데이터에 맞게 처리될 수 있도록 구현
- 기능 또는 데이터에 접근하려는 사용자별로 중요도를 구분하고, 차별화된 인증 방안을 적용
- 인증된 사용자가 이용할 데이터에 대해 개별적으로 접근 권한을 부여하여 인가되지 않은 기능과 데이터로의 접근을 차단
- 개인정보나 인증정보와 같은 중요한 정보의 변조, 삭제, 오남용 등을 방지하기 위해 안전한 암호화 기술 적용



### 보안 기능의 보안 약점

- 적절한 인증 없이 중요기능 허용
  - 보안 검사를 우회하여 인증과정 없이 중요한 정보 또는 기능에 접근 및 변경이 가능하다.
  - 중요정보나 기능을 수행하는 페이지에서는 재인증 기능을 수행하도록 하여 방지할 수 있다.
- 부적절한 인가
  - 접근제어 기능이 없는 실행경로를 통해 정보 또는 권한을 탈취할 수 있다.
  - 모든 실행경로에 대해 접근제어 검사를 수행하고, 사용자에게는 반드시 필요한 접근 권한만을 부여하여 방지할 수 있다.
- 중요한 자원에 대한 잘못된 권한 설정
  - 권한 설정이 잘못된 자원에 접근하여 해당 자원을 임의로 사용할 수 있다.
  - 소프트웨어 관리자만 자원들을 읽고 쓸 수 있도록 설정하고, 인가되지 않은 사용자의 중요 자원에 대한 접근 여부를 검사함으로써 방지할 수 있다.
- 취약한 암호화 알고리즘 사용
  - 암호화된 환경설정 파일을 해독하여 비밀번호 등의 중요정보를 탈취할 수 있다.
  - 안전한 암호화 알고리즘을 이용하고, 업무관련 내용이나 개인정보 등에 대해서는 IT보안인증사무국이 안정성을 확인한 암호 모듈을 이용함으로써 방지할 수 있다.
- 중요정보 평문 저장 및 전송
  - 암호화되지 않은 평문 데이터를 탈취하여 중요한 정보를 획득할 수 있다.
  - 중요한 정보를 저장하거나 전송할 떄는 반드시 암호화 과정을 거치도록 하고, HTTPS 또는 SSL과 같은 보안 채널을 이용함으로써 방지할 수 있다.
- 하드코드된 비밀번호
  - 소스코드 유출 시 내부에 하드코드된 패스워드를 이용하여 관리자 권한을 탈취할 수 있다.
  - 패스워드는 암호화하여 별도의 파일에 저장하고, 디폴트 패스워드나 디폴트 키의 사용을 피함으로써 방지할 수 있다.



## 183) 시간 및 상태(C)

: 동시 수행을 지원하는 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원활하게 동작되도록 하기 위한 보안 검증 항목들이다.

- 시간 및 상태를 점검하지 않은 코딩이 유발하는 보안 약점에는 TOCTOU 경쟁 조건, 잘못된 반복문, 재귀함수 등이 있다.



### TOCTOU 경쟁 조건

: 검사 시점과 사용시점을 고려하지 않고 코딩하는 경우 발생하는 보안 약점

- 검사 시점에는 사용이 가능했던 자원이 사용시점에는 사용할 수 없게 된 경우 발생
- 프로세스가 가진 자원 정보와 실제 자원상태가 일치하지 않는 동기화 오류, 교착상태 등이 발생할 수 있다.
- 코드 내에 동기화 구문을 사용하여 해당 자원에는 한 번에 하나의 프로세스만 접근 가능하도록 구성함으로써 방지할 수 있다.
- 동기화 구문은 성능 감소를 동반하기 때문에 반드시 필요한 부분에 한정하여 사용해야 한다.
  - 동기화 구문 : 공유 자원에 둘 이상의 프로세스가 접근하는 것을 막는 구문으로, Synchronized, Mutex 등이 있다.



### 종료되지 않는 반복문 또는 재귀함수

: 반복문이나 재귀함수에 종료 조건을 정의하지 않았거나 논리 구조상 종료될 수 없는 경우 발생하는 보안 약점

- 반복문이나 재귀함수가 종료되지 않을 경우 시스템 자원이 끊임없이 사용되어 자원고갈로 인한 서비스 장애 또느 시스템 장애가 발생한다.
- 모든 반복문이나 재귀함수의 수행 횟수를 제한하는 설정을 추가하거나, 종료 조건을 점검하여 반복 또는 호출의 종료 여부를 확인함으로써 방지할 수 있다.



## 184) 에러처리(B)

: 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 오류로 인해 발생할 수 있는 문제들을 예방하기 위한 보안 점검 항목들이다.

- 각 프로그래밍 언어의 예외처리 구문을 통해 오류에 대한 사항을 정의
- 예외처리 구문으로 처리하지 못한 오류들을 중요 정보를 토출시키거나, 실행이 중단되는 등 예기치 못한 문제를 발생시킬 수 있다.
- 예외처리의 미비로 인한 코딩이 유발하는 보안 약점에는 오류 메시지를 통한 정보 노출, 오류 상황 대응 부재, 부적절한 예외처리가 있다.



### 오류 메시지를 통한 정보 노출

: 오류 발생으로 실행 환경, 사용자 정보, 디버깅 정보 등의 중요 정보를 소프트웨어가 메시지로 외부에 노출하는 보안 약점

- 노출되는 경로 및 디버깅 정보는 해커의 악의적인 행위를 도울 수 있다.
- 예외처리 구문에 예외의 이름이나 스택 트레이스를 출력하더록 코딩한 경우 해커는 소프트웨어의 내부를 쉽게 파악할 수 있다
  - 스택 트레이스 : 소프트웨어가 실행 중 호출한 메소드 리스트를 기록한 것
- 오류 발생 시 가능한 한 내부에서만 처리되도록 하거나 메시지를 출력할 경우 최소한의 정보 또는 사전에 준비된 메시지만 출력되도록 함으로써 방지할 수 있다.



### 오류 상황 대응 부재

: 소프트웨어 개발 중 예외처리를 하지 않았거나 미비로 인해 발생하는 보안 약점

- 소프트웨어의 실행이 중단되거나 의도를 벗어난 동작이 유도될 수 있다.
- 오류가 발생할 수 있는 부분에 예외처리 구문을 작성하고, 제어문을 활용하여 오류가 악용되지 않도록 코딩함으로써 방지할 수 있다.



### 부적절한 예외처리

: 함수의 반환값 또는 오류들을 세분화하여 처리하지 않고 광범위하게 묶어 한 번에 처리하거나, 누락된 예외가 존재할 때 발생하는 보안 약점

- 모든 오류들을 세세하게 정의하여 처리할 필요는 없지만, 모든 오류들을 광범위한 예외처리 구문으로 정의해 버리면 예기치 않은 문제가 발생할 수 있다.
- 함수 등이 예상했던 결과와 다른 값을 반환하여 예외로 처리되지 않은 경우 잘못된 값으로 인해 다양한 문제가 발생할 수 있다.
- 모든 함수의 반환값이 의도대로 출력되는지 확인하고, 세분화된 예외처리를 수행함으로써 방지할 수 있다.



## 185) 코드 오류(B)

: <b>구현 단계</b>에서 개발자들이 코딩 중 실수하기 쉬운 형(Type)변환, 자원 반환 등의 오류를 예방하기 위한 보안 점검 항목

- 보안 약점에는 널 포인터 역참조, 부적절한 자원 해제, 해제된 자원 사용, 초기화되지 않은 변수 사용이 있다.



### 널 포인터(Null Pointer) 역참조

: 널 포인터가 가리키는 메모리에 어떠한 값을 저장할 때 발생하는 보안 약점

- 많은 라이브러리 함수들이 오류가 발생할 경우 널 값을 반환하는데, 이 반환값을 포인터로 참조하는 경우 발생
- 대부분의 운영체제에서 널 포인터는 메모리의 첫 주소를 가리키며, 해당 주소를 참조할 경우 소프트웨어가 비정상적으로 종료될 수 있다.
- 공격자가 널 포인터 역참조로 발생하는 예외 상황을 악용할 수 있다.
- 널이될 수 있는 포인터를 이용하기 전에 널 값을 갖고 있는지 검사함으로써 방지할 수 있다.



### 부적절한 자원 해제

: 자원을 반환하는 코드를 누락하거나 프로그램 오류루 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점

- 힙 메모리(Heap Memory), 소켓(Socket) 등의 유한한 시스템 자원이 계속 점유하고 있으면 자원 부족으로 인해 새로운 입력을 처리하지 못 할 수 있다.
- 프로그램 내에 자원 반환 코드가 누락되었는지 확인하고, 오류로 인해 함수가 중간에 종료되었을 때 예외처리에 관계없이 자원이 반환되도록 코딩함으로써 방지할 수 있다.



### 해제된 자원 사용

: 이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생하는 보안 약점

- 반환된 메모리를 참조하는 경우 예상하지 못한 값 또는 코드를 수행하게 되어 의도하지 않은 결과가 발생할 수 있다.
- 반환된 메모리에 접근할 수 없도록 주소를 정하고 있는 포인터를 초기화함으로써 방지할 수 있다.



### 초기화 되지 않은 변수 사용

: 변수 선언 후 값이 부여되지 않은 변수를 사용할 때 발생하는 보안 약점

- 변수가 선언되어 메모리가 할당되면 해당 메모리에 이전에 사용하던 내용이 계속 남아있어 변수가 외부에 노출되는 경우 중요 정보가 악용될 수 있다.
- 변수 선언 시 할당된 메모리를 초기화 함으로써 방지할 수 있다.



## 186) 캡슐화(C)

: 정보 은닉이 필요한 중요한 데이터와 기능을 불충분하게 캡슐화하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검 항목들이다.

- 보안 약점에는 잘못된 세션에 의한 정보 노출, 제거되지 않고 남은 디버그 코드, 시스템 데이터 정보 노출 등이 있다.



### 잘못된 세션에 의한 정보 노출

: 다중 스레드 환경에서 멤버 변수에 정보를 저장할 떄 발생하는 보안 약점

- 싱글톤 패턴에서 발생하는 레이스 컨디션으로 인해 동기화 오류가 발생하거나, 멤버 변수의 정보가 노출될 수 있다.
- 멤버 변수 보다는 지역 변수를 활용하여 변수의 범위를 제한함으로써 방지할 수 있다.



### 제거되지 않고 남은 디버그 코드

: 개발 중에 버그 수정이나 결과값 확인을 위해 남겨둔 코드들로 인해 발생하는 보안 약점

- 소프트웨어 제어에 사용되는 중요한 정보가 디버그 코드로 인해 노출될 수 있다.
- 디버그 코드에 인증 및 식별 절차를 생략하거나 우회하는 코드가 포함되어 있는 경우 공격자가 이를 악용할 수 있다.
- 소프트웨어를 배포하기 전에 코드 검사를 통해 남아있는 디버그 코드를 삭제함으로써 방지할 수 있다.



### 시스템 데이터 정보 노출

: 시스템의 내부 정보를 시스템 메시지 등을 통해 외부로 출력하도록 코딩했을 때 발생하는 보안 약점

- 최소한의 정보만 제공함으로써 방지할 수 있다.



### Public 메소드로부터 반환된 Private 배열

: 선언된 클래스 내에서만 접근이 가능한 Private 배열을 모든 클래스에서 접근이 가능한 Public 메소드에서 반환할 때 발생하는 보안 약점

- Public 메소드가 Private 배열을 반환하면 배열의 주소가 외부로 공개되어 외부에서 접근할 수 있게 된다.

- Private 배열을 별도의 메소드를 통해 조작하거나, 동일한 형태의 복제본으로 반환받은 후 값을 전달하는 방식으로 방지할 수 있다.

- 접근 지정자

  : 프로그래밍 언어에서 특정 개체를 선언할 때 외부로부터의 접근을 제한하기 위해 사용되는 에약어

  | 한정자  | 클래스 내부 | 패키지 내부 | 하위 클래스 | 패키지 외부 |
  | ------- | ----------- | ----------- | ----------- | ----------- |
  | Public  | O           | O           | O           | X           |
  | Default | O           | O           | X           | X           |
  | Private | O           | X           | X           | X           |



### Private 배열에 Public 데이터 할당

: Private 배열에 Public으로 선언된 데이터 또는 메소드의 파라미터를 저장할 때 발생하는 보안 약점

- Private 배열에 Public 데이터를 저장하면 Private 배열을 외부에서 접근할 수 있게 된다.
- Public으로 선언된 데이터를 Private 배열에 저장할 때, 레퍼런스가 아닌 값을 직접 저장함으로써 방지할 수 있다.



## 187) API 오용(C)

: 소프트웨어 <b>구현 단계</b>에서 API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 하기 위한 보안 검증 항목들이다.

- 보안 약점에는 DNS lookup에 의존한 보안 결정, 취약한 API 사용이 있다.



### DNS Lookup에 의존한 보안 결정

: 도메인명에 의존하여 인증이나 접근 통제 등의 보안 결정을 내리는 경우 발생하는 보안 약점

- DNS 엔트리를 속여 동일한 도메인에 속한 서버인 것처럼 위장하거나, 사용자와 서버 간의 네트워크 트래픽을 유도하여 악성 사이트를 경유하도록 조작할 수 있다.
- 공격자는 DNS Lookup을 악용하여 인증이나 접근 통제를 우회하는 수법으로 권한을 탈취한다.
- DNS 검색을 통해 도메인 이름을 비교하지 않고 IP 주소를 직접 입력하여 접근함으로써 방지할 수 있다.



### 취약한 API 사용

: 보안 문제로 사용이 금지된 API를 사용하거나, 잘못된 방식으로 API를 사용했을 때 발생하는 보안 약점

- 보안 문제로 그지된 대표적인 API에는 C언어의 문자열 함수 strcat(), strcpy(), sprintf() 등이 있다.
- 보안 상 안전한 API라 하더라도 자원에 대한 직접 연결이나, 네트워크 소켓을 통한 직접 호출과 같이 보안에 위협을 줄 수 있는 인터페이스를 사용하는 경우 보안 약점이 노출된다.
- 보안 문제로 금지된 함수는 안전한 함수로 대체하고, API의 매뉴얼을 참고하여 보안이 보장되는 인터페이스를 사용함으로써 방지할 수 있다.



## 188) 암호 알고리즘(A)

: 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법을 의미

- 해시(Hash)를 사용하는 단방향 암호화 방식과, 개인키 및 공개키로 분류되는 양방향 암호화 방식이 있다.



### 개인키 암호화(Private Key Encryption) 기법

: 동일한 키로 데이터를 암호화 하고 복호화 한다.

- 데이터베이스 사용자는 평문의 정보 M을 암호화 알고리즘 E와 개인키 K를 이용하여 암호문 C로 바꾸어 저장시켜 놓으면 사용자는 그 데이터베이스에 접근하기 위해 복호화 알고리즘 D와 개인키 K를 이용하여 다시 평문의 정보를 M으로 바꾸어 이용하는 방법

- 대칭 암호 기법 또는 단일키 암호화 기법이라고도 한다.

- 한 번에 하나의 데이터 블록을 암호화 하는 블록 암호화 방식과, 평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화 하는 스트림 암호화 방식으로 분류

  - 블록 암호화 방식 : DES, SEED, AES, ARIA
  - 스트림 암호화 방식 : LFSR, RC4

- <b>장점</b>

  : 암호화/ 복호화 속도가 빠르며, 알고리즘이 단순하고, 공개키 암호 기법보다 파일의 크기가 작다

- <b>단점</b>

  : 사용자의 증가에 따라 관리해야 할 키의 수가 상대적으로 많아 진다.



### 공개키 암호화(Public Key Encryption) 기법

: 데이터를 암호화할 때 사용하는 공개키는 데이터 베이스 사용자에게 공개하고, 복호화할 때 비밀키는 관리자가 비밀리에 관리

- 데이터베이스 사용자는 평문의 정보 M을 암호화 알고리즘 E와 공개키 P를 이용하여 암호문 C로 바꾸어 저장시켜 놓고, 이를 복호화하기 위해서는 비밀키와 복호화 알고리즘에 권한이 있는 사용자만이 복호화 알고리즘 D와 비밀키 S를 이용하여 다시 평문의 정보 M으로 바꿀 수 있는 기법

- 비대칭 암호 기법이라고도 하며, 대표적으로 RSA(Rivest Shamir Adleman) 기법이 있다.

- <b>장점</b>

  : 키의 분배가 용이하고, 관리해야 할 키의 개수가 적다.

- <b>단점</b>

  : 암호화/복호화 속도가 느리며, 알고리즘이 복잡하고, 개인키 암호화 기법보다 파일의 크기가 크다

- 공개키 기반 구조(PKI; Public Key Infrastructure)

  - 공개키 암호 시스템을 안전하게 사용하고 관리하기 위한 정보 보호 표준 방식으로 ITU-T의 X.509 방식과 비X.509방식으로 구분
  - X.509 : 인증 기관에서 발생하는 인증서를 기반으로 상호 인증을 제공
  - 비X.509 : 국가별, 지역별로 맞게 보완 및 개발



### 양방향 알고리즘 종류

- SEED
  - 블록 암호화 알고리즘
  - 블록 크기는 128비트이며, 키 길이에 따라 128, 256으로 분류
- ARIA
  - 블록 암호화 알고리즘
  - 블록의 크기는 128비트이며, 키 길이에 따라 128, 192, 256으로 분류
- DES
  - 개인키 암호화 알고리즘
  - DES를 3번 적용함여 보안을 더욱 강화한 3DES도 있다.
  - 블록의 크기는 64비트이며, 키 길이는 56비트이다.
- AES
  - 개인키 암호화 알고리즘
  - DES의 한계를 느낀 NIST에서 공모한 후 발표
  - 블록의 크기는 128비트이며, 키 길이에 따라 128, 192, 256으로 분류
- RSA
  - 공개키 암호화 알고리즘
  - 큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 만들어 졌다.
  - 공개키와 비밀키를 사용하는데, 여기서 키란 메시지를 열고 잠그는 상수를 의미



### 해시(Hash)

: 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것을 의미

- 해시 알고리즘을 해시 함수라고 부르며, 해시 함수로 변환된 값이나 키를 해시값 또는 해시키라고 부른다.
- 데이터의 암호화, 무결성, 검증을 위해 사용될 뿐만 아니라 정보보호의 다양한 분야에서 활용
- 해시 함수의 종류에는 SHA 시리즈, MD5, N-NASH, SNEFRU 등이 있다.

