# 3. 애플리케이션 설계

## 20) 소프트웨어 아키텍처(A)

### 소프트웨어 아키텍처의 설계

: 소프트웨어의 골격이 되는 기본구조이자, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.

- 소프트웨어 개발 시 적용되는 원치과 지침이며, 이해 관계자들의 의사소통 도구로 사용
- 소프트웨어 아키텍처의 설계는 기본적으로 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정이다.
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정한다.
- 기본원리로는 모듈화, 추상화, 단계적 분해, 정보은닉이 있다.



### 모듈화(Modularity)

: 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지관리등이 용이하도록 시스템의 기능들을 모듈단위로 나누는 것을 의미한다.

- 자주 사용되는 계산식이나 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성을 향상시킬 수 있다.
- 크기를 너무 작게 나누면 개수가 많아져 모듈간의 통합 비용이 많이 든다.
- 크기를 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발비용이 많이 든다.



### 추상화(Abstraction)

: 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것이다.

(불필요한 분은 생략하고 필요한 부분을 강조하여 모델화 하는것)

- 복잡한 문제를 다룰 떄 가장 기본적으로 사용하는 방법으로, 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인 테스트가 가능하다.

- 최소 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악 가능하다.

- <b>추상화의 유형</b>

  | 유형          | 내용                                                         |
  | ------------- | ------------------------------------------------------------ |
  | 과정 추상화   | - 자세한 수행 과정 정의 X<br />- 전반적인 흐름만 파악 할 수 있게 설계하는 방법 |
  | 데이터 추상화 | - 데이터의 세부적인 속성이나 용도 정의 X<br />- 데이터 구조를 대표할 수있는 표현으로 대체하는 방법 |
  | 제어 추상화   | - 이벤트 발생의 정확한 절차나 방법을 정의 X<br />- 대표할 수 있는 표현으로 대체하는 방법 |



### 단계적 분해(Stepwise Refinement)

: Niklaus Wirth에 의해 제안된 하향식 설계 전략으로, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화 시키는 분할 기법이다.

- 추상화의 반복에 의해 세분화
- 기능에서 부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료구조 등 상세한 내역은 가능한 뒤로 미루어 진행



### 정보 은닉(Information Hiding)

: 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

- 어떤 모듈이 기능을 수행하는데 반드시 필요한 기능이 있어 정보은닉된 모듈이 필요한 경우, 필요한 정보만 인터페이스를 통해 주고 받는다.
- 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.



### 소프트웨어 아키텍처의 품질 속성

: 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계 되었는지를 확인하기 위해 품질 평가 요소들을 시스템측면, 비즈니스측면, 아키텍처 측며으로 구분하여 구체화시켜 놓으것이다.

- 시스템 측면

  | 품질 속성   | 내용                                                         |
  | ----------- | ------------------------------------------------------------ |
  | 성능        | - 사용자의 요청과 같은 이벤트가 발생할떄, 적절 하고 빠르게 처리 |
  | 보안        | - 허용되지 않은 접근을 막고, 허용된 접근에는 적절한 서비스 제공 |
  | 가용성      | - 장애 없이 정상적으로 서비스 제공                           |
  | 기능성      | - 사용자가 요구한 기능을 만족스럽게 구현                     |
  | 사용성      | - 사용자가 사용시 헤매지 않도록 명학하고 편리하게 구현       |
  | 변경 용이성 | - 처음 설계 목표와 다른 하드웨어나 플랫폼에서도 동작할 수 있도록 구현 |
  | 확장성      | - 시스템의 용량, 처리능력 등을 확장시켰을때 이를 효과적으로 활용할 수 있도록 구현 |
  | 기타 속성   | - 테스트 용이성, 배치성, 안전성 등                           |

- 비즈니스 측면

  | 품질 속성        | 내용                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | 시장 적시성      | - 정해진 시간에 맞춰 프로그램 출시                           |
  | 비용과 혜택      | - 개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들것 인지를 결정<br />- 유연성이 떨어지는 경우 유지보수에 많은 비용이 소모될 수 있다는 것을 고려 |
  | 예상 시스템 수명 | - 얼마나 오랫동안 사용할 것인지를 고려<br />- 수명이 길어야 한다면 시스템 품질의 '변경용이성', '확장성'을 중요하게 고려 |
  | 기타 속성        | - 목표시장, 공개 일정, 기존 시스템과의 통합 등               |

- 아키텍처 측면

  | 품질 속성      | 내용                                                         |
  | -------------- | ------------------------------------------------------------ |
  | 개념적 무결성  | - 전체 시스템과 시스템을 이루는 구성요소들 간의 일관성을 유지 |
  | 정확성, 완결성 | - 요구사항과 요구사항을 구현하기 위해 발생하는 제약사항들을 모두 충족시키는 것 |
  | 구축 가능성    | - 모듈 단위로 구분된 시스템을 적절하게 분배하여 유연하게 일정을 변경할 수 있도록 하는 것 |
  | 기타 속성      | - 변경성, 시험성, 적응성, 일치성, 대체성 등                  |



### 소프트웨어 아키텍처 설계 과정

: 설게 목표 설정 >> 시스템 타임 결정 >> 아키텍처 패턴 적용 >> 서브시스템 구체화 >> 검토 순으로 진행

- 설계 목표 설정

  : 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 설계 목표를 설정

- 시스템 타입 결정

  : 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택

  - 대화형 시스템 : 사용자의 요구 발생시 시스템이 이를 처리하고 반응하는 시스템

    ex) 온라인 쇼핑몰과 같은 웹 애플리케이션

  - 이벤트 중심 시스템 : 외부의 상태 변화에 따라 동작하는 시스템

    ex) 전화, 비상벨 등의 내장 소프트웨어

  - 변환형 시스템 : 데이터 입력시 정해진 작업들을 수행하여 결과를 출력하는 시스템

    ex) 컴파일러, 네트워크 포로토콜 등

  - 객체 영속형 시스템 : 데이터베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템

    ex) 서버 관리 소프트웨어

- 아키텍처 패턴 적용

  : 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계

- 서브시스템 구체화

  : 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동자고가 인터페이스를 정의

- 검토

  : 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계의 기본 원리를 만족하는지 등을 검토



## 21) 아키텍처 패턴(A)

### 아키텍처 패턴의 개요

: 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미

- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
- 서브시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙, 지침 등이 포함
- 아키텍처 패텅을 아키텍처 스타일 또는 표준 아키텍처라고도 한다.
- 아키텍처 패턴의 장점
  - 시행착오를 줄여 개발 시간을 단축시키고, 고품질 소프트웨어를 생산할 수 있다.
  - 검증된 구조로 개발하기 때문에 안전성이 높다.
  - 이해관계자들이 공통된 아키텍처를 고유할 수 있어 의사소통이 간편해 진다.
  - 시스템 구조를 이해하기 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지 보수를 수행할 수 있다.
  - 시스템의 특성을 개발 전에 예측하는 것이 가능해진다.
- 아키텍처 패턴의 종류
  - 레이어 패턴
  - 클라이언트-서버 패턴
  - 파이프-필터 패턴
  - 모델-뷰-컨트롤러 패턴



### 레이어 패턴

: 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법 주으이 하나

- 각각의 서브시스템들이 계층 구조를 이루며, 상위 계층은 하위 계층에 대한 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트가 된다.

- 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어지며, 변경 사항을 적용할 때도 서로 마주보는 두 계층에만 영향을 미치므로 변경 작업이 용이하다.

- 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다

- 대표적으로 OSI참조 모델이 있다

  : 국제 표준화 기구(ISO)에서 네트워크 프로토콜을 계층별로 구분한 모델

  - 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 구성



### 클라이언트-서버 패턴

: 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴

- 컴포넌트

  : 독립적인 업무 또는 기능을 수행하는 실행코드 기반으로 작성된 모듈

- 사용자는 클라이언트와만 의사사통한다. 즉 사용자는 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스 제공

- 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다.

- 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제와하고 서로 독립적이다.



### 파이프-필터 패턴

: 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴이다

- 데이터 스트림

  : 데이터가 송수신되거나 처리되는 일련의 연속적인 흐름

- 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이

- 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능

- 주로 데이터 변환, 버퍼링, 동기화 등에 사용

- 대표적으로 UNIX의 쉘이 있다.



### 모델-뷰-컨트롤러 패턴

: 서브시스템을 3개의 부분으로 구조화하는 패턴이며, 각 부분의 역할은 다음과 같다.

| 부분                 | 역할                                   |
| -------------------- | -------------------------------------- |
| 모델(Model)          | 서브시스템의 핵심 기능과 데이터를 보관 |
| 뷰(View)             | 사용자에게 정보를 표시                 |
| 컨트롤러(Controller) | 사용자로부터 받은 입력을 처리          |

- 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있다.
- 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다.



### 기타 패턴

- 마스터-슬레이브 패턴
  - 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분한 후, 슬레이브에서 처리된 결과물을 돌려받는 방식의 패턴
  - 마스터 컴포넌트는 모든 작업의 주체
  - 슬레이브 컴포넌트는 마스터 컴포넌트의 지시에 따라 작업을 수행하여 결과를 반환
  - 장애 허용시스템과 병렬 컴퓨팅 시스테메서 주로 활용
- 브로커 패턴
  - 사용자가 원하는 서비스와 특성을 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결
  - 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴
  - 분산 환경 시스템에서 주로 활용
- 피어-투-피어 패턴
  - 피어를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도 있고, 서비스를 제공하는 서버가 될 수도 있는 패턴
  - 클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용
- 이벤트-버스 패턴
  - 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식
  - 4가지 주요 컴포넌트
    - 이벤트를 생성하는 소스(Source)
    - 이벤트를 수행하는 리스너(Listener)
    - 이벤트의 통로인 채널(Channel)
    - 채널들을 관리하는 버스(Bus)
- 블랙보드 패턴
  - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태
  - 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있다.
  - 해결책이 며확하지 않은 문제를 처리하는데 유용한 패턴
  - 음성 인식, 차량 식별, 신호 해석 등에 주로 활용
- 인터프리터 패턴
  - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성
  - 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용



## 22) 객체지향(Object-Orented) (A)

### 객체지향의 개요

: 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발 할 때에도 객체들을 조립해서 작성할 수 있는 기법을 말한다.

- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다.
- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다.
- 복잡한 구조를 단계적,계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리를 지원한다.
- 현실 세게를 모형화하므로 사용자와 개발자가 쉽게 이해할 수 있다.
- 주요 구성요소와 개념
  - 객체(Object)
  - 클래스(Class)
  - 캡슐화(Encapsulation)
  - 상속(Inheritance)
  - 다형성(Polymorphism)



### 객체(Object)

: 데이터와 데이터를 처리하는 함수를 묶어놓으(캡슐화한) 하나의 소프트웨어 모듈

|        |                                                              |
| ------ | ------------------------------------------------------------ |
| 데이터 | - 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 나타낸다<br />- 속성(Attribute), 상태, 변수, 상수, 자료 구조라고도 한다 |
| 함수   | - 객체가 수행하는 기능으로 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘이다.<br />- 객체의 상태를 참조하거나 변경하는 수단이 되는 것으로 메소드(Method), 서비스(Service),<br />동작(Operation), 연산 이라고도 한다. |

- 객체의 특성

  - 독립적으로 식별 가능한 이름을 가지고 있다.

    ex) 자동차의 번호판

  - 객체가 가질 수 있는 조건을 상태(State)라고 하는데, 일반적으로 상태는 시간에 따라 변한다.

    ex) 자동차는 '정지', '이동' 등의 상태가 존재하며, 고정된 것이 아니라 시간에 따라 변한다.

  - 객체와 객체는 상호 연관성에 의한 관계가 형성된다.

    ex) 화재 발생 시 소방차, 구급차, 경찰차는 긴밀하게 협조하는 관계가 형성

  - 객체가 반응할 수 있는 메시지의 집합을 행위라고 하며, 객체는 행위의 특징을 나타낼 수 있다.

    ex) 자동차 객체는 '가속 패달을 밟는 행위'는 '가속'하는 행위, '브레이크를 밟는 행위'는 '감속'하는 특징을 나타낸다.

  - 객체는 일정한 기억장소를 가지고 있다.

    ex) 자동차는 주차장에 있거나 도로 위에 있거나, 일정한 물리적 공간을 점유한다.

- 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다.



### 클래스(Class)

: 공통된 속성과 연산(행위)을 갖는 객체의 집합으로 객체의 일반적인 타입을 의미

- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
- 클래스에 속한 각각의 객체를 인스턴스(Instance)라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 한다.
- 동일 클래스에 속한 각각의 객체들은 공통된 속성과 행위를 가지고 있으며, 그 속성에 대한 정보가 서로 달라서 동일 기능을 하는 여러 가지 객체를 나타낸다.
- 최상위 클래스는 상위 클래스를 갖지 않는 클래스를 의미한다.
- 슈퍼클래스는 특정 클래스의 상위(부모) 클래스이고, 서브 클래스는 특정 클래스의 하위(자식) 클래스를 의미한다.



### 캡슐화(Encapsulation)

: 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미

- 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급효과가 적다
- 재사용이 용이하다.
- 객체들 간의 메시지르 ㄹ주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체간의 결합도가 낮아진다.



### 상속(Inhertiance)

: 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

- 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 물려 받는다.

- 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.

- 상위 클래스의 연산과 속성을 사용할 수 있기 때문에 객체와 클래스의 재사용을 높이는 중요한 개념이다.

- <b>다중상속(Multi Inheritance)</b>

  : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 상속받는 것

  (상위 클래스의 변경이 의도치 않은 영향을 미칠 수도 있으므로 이를 고려하여 신중히 사용해야 한다.)



### 다형성(Polymorphism)

: 메시지에 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력을 의미

- 객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다.
- 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스 처럼 수행할 수 있도록 하는 것이다.



## 23) 모듈(A)

: 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용

- 모듈화

  : 소프트웨어의 성능 향상, 수정 및 재사용, 유지관리 등이 용이하도록 기능들을 모듈단위로 분해하는 것을 의미

  - 루틴 : 기능을 가진 명령의 모임
  - 메인루틴 : 프로그램 실행의 큰 줄기가 되는 것
  - 서브 루틴 : 메인 루틴에 의해 필요할 때 마다 호출되는 루틴

- 단독으로 컴파일이 가능하며, 재사용 할 수 있다.

- 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로서 이루어진다.

- 독립성이 높은 모듈일수록 다른 모듈들에게는 거의 영향을 미치지 않고, 오류를 쉽게 발견하고 해결할 수 있다.

- 모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 한다.



### 결합도(Coupling)

: 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미

- 다양한 결합으로 모듈을 구성할 수 있으나 결합도가 약할수로 품직이 높고, 강할수록 품질이 낮다.

- 결합도가 강하면 시스템 구현 및 유지보수가 어렵다.

- <b>결합도의 종류</b>

  : 자료 결합도, 스탬프 결합도, 제어 결합도, 외부 결합도, 공통 결합도, 내용 결합도

  (결합도가 약함<------------------------------------------------------------>결합도가 강함)

  - 자료 결합도
    - 모듈 간의 인터페이스가 자료 요소로만 구성될 떄의 결합도
    - 다른 모듈을 호출하면서 매개 변수나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 방식이다.
    - 한 모듈의 내용을 변경하더라도 다른 모듈에는 전혀 영향을 미치지 않는 가장 바람직한 결합도
  - 스탬프(검인) 결합도
    - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될때 결합도
    - 두 모듈이 동일한 자료 구조를 조회하는 경우의 결합도
    - 자료 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 조회하지 않는 모듈에 까지도 영향을 미침
  - 제어 결합도
    - 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 시놓를 이용하여 통신하거나 제어 요소를 전달하는 결합도
    - 다른 모듈의 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생
    - 하위 모듈 > 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상 발생
  - 외부 결합도
    - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
    - 참조되는 데이터의 범위를 각 모듈에서 제한할 수 있다.
  - 공통(공유) 결합도
    - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
    - 공통 데이터 영역을 조금만 변경하더라도 모든 모듈에 영향을 미치므로 독립성을 약하게 만든다.
  - 내용 결합도
    - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
    - 한 모듈에서 다른 모듈릐 내부로 제어가 이동하는 경우에도 내용 결합도에 해당된다.



### 응집도(Cohesion)

: 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈의 독립적인 기능으로 정의되어 있는 정도를 의미 한다.

- 다양한 기준으로 모듈을 구성할 수 있으나 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다

- 응집도의 종류

  : 기능적, 순차적, 교환적, 절차적, 시간적, 논리적, 우연적

  (응집도 강함<----------------------------------->응집도 약함)

  - 기능적 응집도(Functional Cohesion)
    - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
  - 순차적 응집도(Sequential Cohension)
    - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력데이터로 사용할 경우의 응집도
  - 교환(통신)적 응집도(Communication Cohesion)
    - 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성요소들이 모였을 경우의 응집도
  - 절차적 응집도(Procedural Cohension)
    - 모듈이 다수의 관련 기능을 가질때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
  - 시간적 응집도(Temporal Cohesion)
    - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
  - 논리적 응집도(Logical Cohesion)
    - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
  - 우연적 응집도(Coincidental Cohesion)
    - 모듈 내부의 각 구성 요소딜이 서로 관련없는 요소로만 구성된 경우의 응집도



### 팬인(Fan-In) / 팬아웃(Fan-Out)

- 팬인은 어떤 모듈을 제어(호출)하는 모듈의 수를 나타낸다
- 팬아웃 어떤 모듈에 의해 제어(호출)되는 모듈의 수를 나타낸다.
- 팬인과 팬아웃을 분석하여 시스템의 복잡도를 알 수있다.
- 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있으나, 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요하다.
- 팬 아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고, 단순화시킬 수 있는지 여부에 대한 검토가 필요하다.
- 시스템의 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계해야한다



## 24) 공통 모듈(C)

### 공통 모듈의 개요

: 여러 프로그램에서 공통적으로 사용할 수 있는 모듈을 의미

- 자주 사용되는 계산식이나 매번 필요한 기능들이 공통 모듈로 구성될 수 있다.

- 모듈의 재사용성 확보와 중복 개발 회피를 위해 설계 과정에서 공통 부분을 식별하고 명세를 작성할 필요가 있다.

- 다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 다음의 명세 기법을 준수 해야한다.

  - 정확성(Correctness)

    : 시스템 구현시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성한다.

  - 명확성(Clarity)

    : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성한다.

  - 완전성(Completeness)

    : 시스템 구현을 위해 필요한 모든 것을 기술한다.

  - 일관성(Consistency)

    : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성한다.

  - 추적성(Traceability)

    : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성한다.



### 재사용(Reuse)

: 비용과 개발 시간을 절약하기 위해 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업이다.

- 재사용을 위해서는 누구나 이해할 수 있고, 사용이 가능하도록 사용법을 공개해야 한다.

- 재사용되는 대상은 외부 모듈과의 결합도가 낮고, 응집도는 높아야 한다.

- 재사용 규모에 따른 분류

  - 함수와 객체

    : 클래스나 메소드 단위의 소스 코드를 재사용한다.

  - 컴포넌트

    : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용한다.

  - 애플리케이션

    : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용한다.



### 효과적인 모듈 설계 방안

- 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다.
- 모듈의 제어 영역 안에서 그 모듈의 영향영역을 유지시킨다.
- 복잡도와 중복성을 줄이고 일관성을 유지시킨다.
- 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.
- 유지보수가 용이해야 한다.
- 모듈의 크기는 기능과 구조를 이해하기 쉬운 크기로 분해한다.
- 하나의 입구와 하나의 출구를 갖도록 해야한다.
- 인덱스 번호나 기능 코드들이 처리 논리 구조에 예기치 못한 영향을 끼치지 않도록 모듈 인터페이스를 설계해야 한다.



## 25) 코드(B)

### 코드의 개요

: 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류,조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호이다.

- 정보를 신속,정확,명료하게 전달할 수 있게 한다.
- 일정한 규칙에 따라 작성되며, 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다.
- 일반적인 코드의 예로 주민등록번호, 학번, 전화번호가 있다.
- 주요기능에는 식별기능, 분류기능, 배열기능이 있다.
  - 식별 기능 : 데이터의 간의 성격에 따라 구분이 가능
  - 분류 기능 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있다.
  - 배열 기능 : 의미를 부여하여 나열할 수 있다.



### 코드의 종류

- 순차 코드(Sequence Code)

  : 자료의 발생 순서, 크기 순서 등 일정 기준에 따라 차례대로 일련번호를 부여하는 방법으로, 순서 코드 또는 일련번호 코드라고도 한다.

  ex) 1,2,3,4 ....

- 블록 코드(Block Code)

  : 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호 를 부여하는 방법으로, 구분 코드라고도 한다

  ex) 1001~1100 : 총무부, 1101~1200 : 영업부

- 10진 코드(Decimal Code)

  : 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 한다.

  ex) 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계

- 연상 코드(Mnemonic Code)

  : 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법

  ex) TV-40 : 40인치 TV, L-15-220 : 15W 220V의 램프

- 표의 숫자 코드(Significant Digit Code)

  : 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법으로, 유효숫자 코드라고도 한다.

  ex) 120-720-1500: 두께X폭X길이가 120X720X1500인 강판

- 합성 코드(Combined Code)

  : 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법

  ex) 연상 코드 + 순차 코드 >> KE-711 : 대한항공 711기



### 코드 부여 체계

: 이름만으로 개체의 용도와 적용범위를 알 수 있도록 코드를 부여하는 방식

- 각 개체에 유일한 코드를 부여하여 개체들의 식별 및 추출을 용이하게 한다.
- 코드를 부여하기 전에 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의 되어야 한다
- 코드 부여 체계를 담당하는 자는 코드의 자릿수와 구분자, 구조 등을 상세하게 명시해야 한다.



## 디자인 패턴(B)

### 디자인 패턴의 개요

: 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.

- 재사용할 수 있는 기본형 코드들이 포함되어 있다.
- 개발 과정 중에 문제가 발생하면 새로운 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다.
- 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징이 있다.
- 1995년 GOF라고 불리는 에릭 감마, 리차드 헬름, 랄프 존슨, 존블리시디스가 처음으로 구체화 및 체계화하였다.
- GOF의 디자인 패턴은 수맣은 디자인 패턴들 중 가장 일반적인 사례에 저용될 수 있는 패턴들을 분류하여 정리함으로써, 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴이다.
- GOF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다.
- 아키텍처 패턴 VS 디자인 패턴
  - 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용된다.
  - 아키텍처 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델이다.
  - 몇몇 디자인 패턴은 특정 아키텍처 패턴을 구현하는데 유용하게 사용된다.



### 생성 패턴(Creational Pattern)

: 객체의 생성과 관련된 패턴으로 총 5개의 패턴이 있다.

- 객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록하여 프로그램에 유연성을 더해준다.
- 종류
  - 추상 팩토리(Abstract Factory)
    - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.
    - 연관된 서브 클래스를 묶어 한번에 교체하는 것이 가능
  - 빌더(Builder)
    - 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성
    - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.
  - 팩토리 메소드(Factory Method)
    - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
    - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
  - 프로토타입(Prototype)
    - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
    - 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용
  - 싱글톤(Singleton)
    - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.
    - 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있다.



### 구조 패턴(Structural Pattern)

: 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로 총 7개의 패턴이 있다.

- 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.
- 종류
  - 어댑터(Adapter)
    - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 사용할 수 있도록 변환 해주는 패턴
    - 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을때 이용
  - 브리지(Bridge)
    - 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
    - 기능과 구현을 두 개의 별도 클래스로 구현
  - 컴포지트(Composite)
    - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
    - 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체안에 복합 객체가 포함되는 구조를 구현 할 수 있다.
  - 데코레이터(Decorator)
    - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴(동적으로 할당)
    - 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현
  - 퍼싸드(Facade)
    - 복잡한 서브 클래스들을 피해 더 상위 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
    - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요하다.
  - 플라이웨이트(Flyweight)
    - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
    - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있다.
  - 프록시(Proxy)
    - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
    - 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용한다.



### 행위 패턴(Behavioral Pattern)

: 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로 총 11개의 패턴이 있다.

- 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결하도를 최소화 할 수 있도록 도와준다.
- 종류
  - 책임 연쇄(Chain of Responsibility)
    - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 현태의 패턴
    - 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어간다.
  - 커맨드(Command)
    - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소 할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
    - 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화
  - 인터프리터(Interpreter)
    - 언어에 문법 표현을 정의하는 패턴
    - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
  - 반복자(Iterator)
    - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
    - 내부 표현방법의 노출 없이 순차적 접근이 가능
  - 중재자(Mediator)
    - 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화 하여 객체로 정의하는 패턴
    - 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있다.
  - 메멘토(Memento)
    - 특정 시점에서의 객체 내부 상태를 객체화 함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
    - ctrl+z 와 같은 되돌리기 기능을 개발할 때 주로 이용
  - 옵서버(Observer)
    - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
    - 주로 분산된 시스템 간에 이벤트 생성, 발행하고, 이를 수신해야 할 때 이용
  - 상태(State)
    - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
    - 객체상태를 캡슐화하고 이를 참조하는 방식으로 처리
  - 전략(Strategy)
    - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
    - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향없이 알고리즘의 변경이 가능
  - 템플릿 메소드(Template Method)
    - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
    - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해준다.
  - 방문자(Visitor)
    - 각 클래스들의 데이터 구조에서 처리기능을 분리하여 별도의 클래스로 구성하는 패턴
    - 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행한다.