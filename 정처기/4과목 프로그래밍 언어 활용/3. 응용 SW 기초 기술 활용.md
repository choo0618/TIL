# 3. 응용 SW 기초 기술 활용

## 141) 운영체제의 개념(A)

### 운영체제(OS; Operating System)

: 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임

- 사용자와 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.
- 사용자 >> 응용 프로그램 >> 유틸리티 >> 운영체제 >> 하드웨어



### 운영체제의 목적

: 성능을 평가하는 기준

- 처리 능력(Throughtput)

  : 일정 시간 내에 시스템이 처리하는 일의 양

- 반환 시간(Turn Around Time)

  : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간

- 사용 가능도(Abailability)

  : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도

- 신뢰도(Reliability)

  : 시스템이 주어진 문제를 정확하게 해결하는 정도



### 운영체제의 기능

- 프로세서(처리기), 기억장치(주기억장치, 보조기억장치), 입출력장치, 파일 및 정보 등의 자원을 관리
- 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공
- 사용자와 시스템 간의 편리한 인터페이스를 제공
- 시스템의 각종 하드웨어와 네트워크를 관리 및 제어
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
- 시스템의 오류를 검사하고 복구
- 자원 보호 기능을 제공
- 입출력에 대한 보조 기능을 제공
- 가상 계산기 기능을 제공



### 운영체제의 주요 자원 관리

| 자원          | 기능                                                         |
| ------------- | ------------------------------------------------------------ |
| 프로세스 관리 | - 프로세스 스케줄링 및 동기화 관리 담당<br />- 프로세스 생성과 제거, 시작과 정지, 메시지 전달 등의 기능 담당 |
| 기억장치 관리 | - 프로세스에게 메모리 할당 및 회수 관리 담당                 |
| 주변장치 관리 | - 입출력장치 스케줄링 및 전반적인 관리 담당                  |
| 파일 관리     | - 파일의 생성과 삭제, 변경, 유지 등의 관리 담당              |



### 운영체제의 종류

| 운영체제 | 특징                                                         | 인터페이스 |
| -------- | ------------------------------------------------------------ | ---------- |
| Windows  | - 마이크로소프트 사가 개발한 운영체제                        | GUI        |
| UNIX     | - AT&T 벨 연구소, MIT, General Electric 이 공동 개발한 운영체제 | CLI        |
| LINUX    | - UNIX와 호환이 가능한 커널이며, 리눅스 토발즈가 개발한 운영체제<br />- 누구나 제한 없이 활용 및 재배포 가능 | CLI        |
| MacOS    | - 애플 사가 UNIX를 기반으로 개발한 운영체제                  | GUI        |
| MS-DOS   | - Windows 이전에 사용되던 운영체제                           | CLI        |

- 단일 작업 처리 시스템에는 MS-DOS, 다중 작업 처리 시스템에는 Windows, UNIX, LINUX, MacOS 등이 있다.
- Windows, MacOS, MS-DOS는 개인용, UNIX, LINUX는 서버용 운영체제이다.
- 단일 작업 처리 시스템 / 다중 작업 처리 시스템
  - 단일 작업 처리 시슷템
    - 컴퓨터 시스템을 한 개의 작업이 독점하여 사용하는 방식
  - 다중 작업 처리 시스템
    - 여러 개의 프로그램을 열어 두고 다양한 작업을 동시에 진행하는 방식



## 142) Windows(C)

: 마이크로소프트 사가 개발한 운영체제

- 버전에는 95, 98, me, xp, vista, 7, 8, 10 등이 있다.
- 주용 특징에는 GUI, 선점형 멀티태스킹, OLE, PnP 등이 있다.



### 그래픽 사용자 인터페이스(GUI; Graphic User Interface)

: 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식

- 초보자도 쉽게 사용할 수 있는 그래픽 사용자 인터페이스를 채용



### 선점형 멀티태스킹(Preemptive Multi-Tasking)

: 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식

- 하나의 응용 프로그램이 CPU를 독점하는 것을 방지할 수 있어 시스템 다운 현상없이 더욱 안정적인 작업 가능



### PnP(Plug and Play, 자동 감지 기능)

: 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 떄, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영 체제가 자동으로 구성해 주는 기능

- 운영체제가 하드웨어의 규격을 자동으로 인식하여 동작하게 해주므로 PC 주변장치를 연결할 때 사용자가 직접 환경을 설정하지 않아도 된다.
- PnP 기능을 활용하기 위해서는 하드웨어와 소프트웨어 모두 PnP를 지원하여야 한다.



### OLE(Object Linking and Embedding)

: 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있게 제어하는 기능

- 연결된 이미지를 원본 프로그램에서 수정하거나 편집하면 그 내용이 그대로 해당 문서에 반영



### 265자의 긴 파일명

: 파일 이름을 지정할 떄 VFAT(Virtual File Allocation Table)를 이용하여 최대 255자까지 지정 가능

- 파일 이름으로 ₩ / : * ? " < > | 를 제외한 모든 문자 및 공백을 사용할 수 있으며, 한글의 경우 127자 까지 가능



### Single-User 시스템

: 컴퓨터 한 대를 한 사람만이 독점해서 사용한다.



### 143) UNIX / LINUX / MacOS (A)

### UNIX의 개요 및 특징

- 시분할 시스템을 위해 설계된 대화식 운영체제로, 소스가 공개된 개방형 시스템이다.
- 대부분 C 언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높다.
- 크기가 작고 이해하기 쉽다.
- 다중 사용자, 다중 작업을 지원
  - 다중 사용자는 여러 사용자가 동시에 시스템을 사용하는 것이고, 다중 작업은 여러 개의 작업이나 프로그램을 동시에 수행하는 것을 의미
  - 하나 이상의 작업을 백그라운드에서 수행하므로 여러 작업을 동시에 처리 가능
- 많은 네트워킹 기능을 제공하므로 통신망 관리용 운영체제로 적합
- 트리 구조의 파일 시스템을 갖는다.
- 전문적인 프로그램 개발에 용이
- 다양한 유틸리티 프로그램들이 존재



### UNIX 시스템의 구성

#### 커널(Kernel)

- UNIX의 가장 핵심적인 부분
- 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당
- 프로세스관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행

### 쉘(Shell)

- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
- 시스템과 사용자 간의 인터페이스를 담당
- DOS의 COMMAND.COM과 같은 기능을 수행
- 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능
- 파이프라인 기능을 지원하고 입출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있다.
- 공용 Shell이나 사용자 자신이 만든 Shell을 사용 가능

#### Utility Program

- 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용
- DOS에서의 외부 명령어에 해당
- 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있다.

#### UNIX에서의 프로세스 간 통신

: 각 프로세스는 시스템 호출을 통해 커널의 기능으 ㄹ사용하며, 프로세스 간 통신은 시그널, 파이프, 소켓 등을 사용

- 시크널(Signal) : 간단한 메시지를 이용하여 통신하는 것으로 초기 UNIX 시스템에서 사용됨
- 파이프(Pipe) : 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식
- 소켓(Socket) : 프로세스 사이의 대화를 가능하게 하는 쌍방향 통신 방식



### LINUX의 개요 및 특징

- 프로그램 소스 코드가 무료로 공개되어 있기 때문에 프로그래머가 원하는 기능을 추가할 수 있고, 다양한 플랫폼에 설치하여 사용이 가능하며, 재배포가 가능
- UNIX와 완벽하게 호환된다.
- 대부분의 특징이 UNIX와 동일



### MacOS의 개요 및 특징

- 아이맥 맥북 등 애플 사에서 생산하는 제품에서만 사용이 가능
- 드라이버 설치 및 install과 uninstall의 과정이 단순하다.



## 144) 기억장치 관리의 개요(A)

### 기억장치 계층 구조의 특징

: 기억장치는 레지스터, 캐시 기억장치, 주기억장치, 보조기억장치를 다음과 같이 계층 구조로 분류 가능

레지스터 <<>> 캐시 기억장치 <<>> 주기억장치 <<>> 보조기억장치

(증가                         접근 속도 비트당 가격                               감소)

(감소                           접근 시간 기억 용량                                증가)

- 계층 구조 에서 상위의 기억장치일수록 접근 속도와 접근 시간이 빠르지만, 기억 용량이 적고 고가이다.
- 주기억장치는 각기 자신의 주소를 갖는 워드 또는 바이트들로 구성되어 있으며, 주소를 이용하여 액세스할 수 있다.
- 레지스터, 캐시 기억장치, 주기억장치의 프로그램과 데이터는 CPU가 직접 액세스 할 수 있으나 보조기억장치에 있는 프로그램이나 데이터는 직접 액세스 할 수 없다.
- 보조기억장치에 있는 데이터는 주기억장치에 적재된 후 CPU에 의해 액세스될 수 있다.



### 기억장치의 관리 전략의 개요

: 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의  공간을 효율적으로 사용하기 위한 것으로 반입 전략, 배치 전략, 교체 전략이 있다.



### 반입(Fetch) 전략

: 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략

- <b>요구 반입(Demand Fetch)</b>

  : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법

- <b>예상 반입(Anticipatory Fetch)</b>

  : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법



### 배치(Placement) 전략

: 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬것인지를 결정하는 전략

- <b>최초 적합(First Fit)</b>

  : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법

- <b>최적 적합(Best Fit)</b>

  : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법

- <b>최악 적합(Worst Fit)</b>

  : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법



### 교체(Replacement) 전략

: 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략

-  교체 전략에는 FIFO, OPT, LRU, LFU, NUR, SCR 등이 있다.



## 145) 주기억장치 할당 기법(C)

: 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용이며, 연속 할당 기법과 분산 할당 기법으로 분류할 수 있다.

- 연속 할당 기법

  : 프로그램을 주기억장치에 연속으로 할당하는 기법으로, 단일 분할 할당 기법과 다중 분할 할당 기법이 있다.

  - 단일 분할 할당 기법 : 오버레이, 스와핑
  - 다중 분할 할당 기법 : 고정 분할 할당 기법, 동적 분할 할당 기법

- 분산 할당 기법

  : 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법으로, 페이징 기법과 세그먼테이션 기법으로 나눌 수 있다.



### 단일 분할 할당 기법

: 주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한 순간에 오직 한명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법

- 가장 단순한 기법으로 초기의 운영체제에서 많이 사용하던 기법이다.
- 운영체제를 보호하고, 프로그램이 사용자 영역만을 사용하기 위해 운영체제 영역과 사용자 영역을 구분하는 경계 레지스터가 사용된다.
- 프로그램의 크기가 작을 경우 사용자 영역이 낭비될 수 있다.
- 초기에는 주기억장치보다 큰 사용자 프로그램은 실행할 수 없었으나 오버레이 기법을 사용하면서 이 문제가 해결되었다.

#### 오버레이(Overlay) 기법

: 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법

- 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행
- 프로그램이 실행되면서 주기억장치의 공간이 부족하면 주기억장치에 적재된 프로그램의 조각 중 불필요한 조각이 위치한 장소에 새로운 프로그램의 조각을 중첩(Overlay)하여 적재
- 프로그램을 여러 개의 조각으로 분할하는 작업은 프로그래머가 수행해야 하므로 프로그래머는 시스테 ㅁ구조나 프로그램 구조를 알아야 한다.

#### 스와핑(Swapping) 기법

: 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법

- 주기억장치에 있는 프로그램이 보조기억장치로 이동되는 것을 Swap Out, 보조기억장치에 있는 프로그램이 주기억장치로 이동되는 것 Swap In이라고 한다.
- 하나의 사용자 프로그램이 완료될 때 까지 교체 과정을 여러 번 수행할 수 있다.
- 가상기억장치의 페이징 기법으로 발전



### 다중 분할 할당 기법

#### 고정 분할 할당(MFT) 기법 = 정적 할당(Static Allocation) 기법

: 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 서행하는 기법

- 프로그램을 실행하려면 프로그램 전체가 주기억장치에 위치해야 한다.
- 프로그램이 분할된 영역보다 커서 영역 안에 들어갈 수 없는 경우가 발생할 수 있다.
- 일정한 크기의 분할 영역에 다양한 크기의 프로그램이 할당되므로 내부 단편화 및 외부 단편화가 발생하여 주기억장치의 낭비가 많다.
- 실행할 프로그램의 크기를 미리 알고 있어야 한다.
- 다중 프로그래밍을 위해 사용되었으나 현재는 사용되지 않는다.

- 절대 번역과 적재

  : 할당될 분할 영역을 어셈블러나 컴파일러가 지정하는 방식으로, 각 프로그램은 준비상태 큐에서 기다리며, 다른 분할 영역이 비어 있다 하더라도 지정된 분할 영역만을 사용해야 한다.

- 재배치 번역과 적재

  : 할당될 영역이 미리 지정되지 안혹, 하나의 준비상태 큐에서 기다린 순서대로 분할 영역에 할당되는 방식



#### 가변 분할 할당(MVT) 기법 = 동적 할당(Dynamic Allocation) 기법

: 고정 분할 할당 기법의 단편화를 줄이기 위한 것으로, 미리 주기억장치를 분할해 놓는 것이 아니라 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법

- 주기억장치를 효율적으로 사용할 수 있으며, 다중 프로그래밍의 정도를 높일 수 있다.
- 고정 분할 할당 기법에 비해 실행될 프로세스 크기에 대한 제약이 적다.
- 단편화를 상당 부분 해결할 수 있으나 영역과 영역 사이에 단편화가 발생할 수 있다.



## 146) 가상기억장치 구현 기법 / 페이지 교체 알고리즘 (A)

### 가상기억장치의 개요

: 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것 처럼 사용하는 기법

- 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리
- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용
- 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.
- 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업이 있다.
- 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있다.
- 구현방법에는 블록의 종류에 따라 페이징 기법과 세그먼테이션 기법으로 나눌 수 있다.



### 페이징(Paging) 기법

: 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 주기억장치의 영역에 적재시켜 실행하는 기법

- 프로그램을 일정한 크기로 나눈 단위를 페이지라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 당=ㄴ위를 페이지 프레임이라고 한다.
- 외부 단편화는 발생하지 않으나 내부단편화는 발생할 수 있다.
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다.
- 페이지 맵 테이블 사용으로 비용이 증가되고, 처리 속도가 감소된다.



### 세그먼테이션(Segmentation) 기법

: 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법

- 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법이다.
- 기억공간을 절약하기 위해 사용
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키가 필요
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.



### 페이지 교체 알고리즘

: 페이지 부재가 발생하였을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법

#### OPT(OPTimal replacement, 최적 교체)

- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
- 벨레이디가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘

#### FIFO(First In First Out)

- 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 방법
- 이해하기 쉽고, 프로그래밍 및 설계가 간단하다.

#### LRU(Least Recently Used)

- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
- 각 페이지마다 계수기나 스택을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체

#### LFU(Least Frequently Used)

- 사용 빈도가 가장 적은 페이지를 교체하는 기법
- 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다.

#### NUR(Not Used Recently)

- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
- 최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
- 최근의 사용 여부를 확인하기 위해서는 각 페이지마다 두 개의 비트, 즉 참조 비트와 변형 비트가 사용된다.

#### SCR(Second Chance Replacement, 2차 기회 교체)

- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법



## 147) 가상기억장치 기타 관리 사항(A)

: 가상기억장치를 구현할 때 시스템의 성능에 영향을 미치는 것으로는  페이지 크기나 Locality, 워킹 셋, 페이지 부재 빈도, 프리페이징 등이 있다.



### 페이지 크기

: 페이징 기법을 사용하면 프로그램을 페이지 단위로 나누게 되는데, 페이지의 크기에 따라 시스템에 미치는 영향이 다르다. 페이지 크기에 따른 특징은 다음과 같다.

#### 페이지 크기가 작을 경우

- 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.
- 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋을 유지할 수 있다.
- Locality에 더 일치할 수 있기 때문에 기억장치 효율이 높아진다.
- 페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어진다.

#### 페이지 크기가 클 경우

- 페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다.
- 디스크 접근 횟수가 줄어들어 전체적인 입출력의 효율성이 증가된다.
- 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.
- 프로세스(프로그램) 수행에 불필요한 내용까지도 주기억장치에 적재될 수 있따.



### Locality

: 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론

- 스래싱을 방지하기 위한 워킹 셋 이론의 기반이 되었다.
- 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법 중 하나로, 가상기억장치 관리의 이론적인 근거가 된다.
- 종류에는 시간 구역성, 공간 구역성이 있다.

#### 시간 구역성(Temporal Locality)

- 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상이다.

- 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미

- <b>시간 구역성이 이루어지는 장소</b>

  : Loop, 스택, 부 프로그램, Counting, 집계에 사용되는 변수(기억장소)

#### 공간 구역성(Spatial Locality)

- 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상

- 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음을 의미

- <b>공간 구역성이 이루어지는 기억장소</b>

  : 배열 순회, 순차적 코드의 실행, 프로그래머들이 관련된 변수들을 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때 사용



### 워킹 셋(Working Set)

: 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합

- 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정
- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경된다.



### 페이지 부재 빈도 방식

: 페이지 부재는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상이며, 페이지 부재 빈도(PFF)는 페이지 부재가 일어나는 횟수를 의미

- 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식
- 운영체제는 프로세스 실행 초기에 임의의 페이지 프레임을 할당하고, 페이지 부재율은 지속적으로 감시하고 있다가 부재율이 상한선을 넘어가면 좀더 많은 페이지프레임을 할당하고, 하한선을 넘어가면 페이지 프레임을 회수하는 방식을 사용



### 프리페이징(Prepaging)

: 처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지르 ㄹ한꺼번에 페이지 프레임에 적재하는 기법

- 기억장치에 들어온 페이지들 중에서 사용되지 않는 페이지가 많을 수도 있다.



### 스래싱(Thrashing)

: 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상

- 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정중 자주 페이지 부재가 발생함으로써 나타나는 현상으로, 전체 시스템의 성능이 저하된다.
- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소한다.
- <b>스래싱 현상 방지 방법</b>
  - 다중 프로그래밍의 정도를 적정 수준으로 유지
  - 페이지 부재 빈도를 조절하여 사용
  - 워킹 셋을 유지
  - 부족한 자원을 증설하고, 일부 프로세스를 중단
  - CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영



## 148) 프로세스의 개요(A)

### 프로세스(Process)의 정의

: 일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미하며, 작업(Job), 태스크(Task)라고 하낟.

- 형태에 따른 프로세스의 정의
  - PCB를 가진 프로그램
  - 실기억장치에 저장된 프로그램
  - 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
  - 프로시저(작은 프로그램으로 분할된 프로그램, 부프로그램)가 활동중인 것
  - 비동기적 행위(다수의 프로세스가 독립적으로 실행 되는 것)를 일으키는 주체
  - 지정된 결과를 얻기 위한 일련의 계통적 동작
  - 목적 또는 결과에 따라 발생되는 사건들의 과정
  - 운영체제가 관리하는 실행 단위



### PCB(Process Control Block, 프로세스 제어 블록)

: 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳으로, Task Control Block 또는 Job Control Block이라고도 한다.

- 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.

- PCB에 저장되어 있는 정보

  | 저장 정보                       | 설명                                                         |
  | ------------------------------- | ------------------------------------------------------------ |
  | 프로세스의 현재 상태            | - 준비, 대기, 실행 등의 프로세스 상태                        |
  | 포인터                          | - 부모(자식) 프로세스에 대한 포인터 : 부모(자식) 프로세스의 주소 기억<br />- 프로세스가 위치한 메모리에 대한 포인터 : 현재 프로세스가 위치한 주소 기억<br />- 할당된 자원에 대한 포인터 : 프로세스에 할당된 각 자원에 대한 주소 기억 |
  | 프로세스 고유 식별자            | - 프로세스를 구별할 수 있는 고유의 번호                      |
  | 스케줄링 및 프로세스의 우선순위 | - 스케줄링 정보 및 프로세스가 실행될 우선순위                |
  | CPU 레지스터 정보               | - 누산기, 인덱스 레지스터, 범용 레지스터, 프로그램 카운터 등에 대한 정보 |
  | 주기억장치 관리 정보            | - 기준 레지스터, 페이지 테이블에 대한 정보                   |
  | 입출력 상태 정보                | - 입출력장치, 개방된 파일 목록                               |
  | 계정 정보                       | - CPU 사용 시간, 실제 사용 시간, 한정된 시간                 |



### 프로세스 상태 전이

: 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미하며, 프로세스의 상태를 상태 전이도로 표시할 수 있다.

- 프로세스의 상태는 제출, 접수, 준비, 실행, 대기 상태로 나눌 수 있으며, 이 중 주요 세 가지 상태는 준비, 실행, 대기 상태이다.

- <b>제출(Submit)</b>

  : 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태이다.

- <b>접수(Hold)</b>

  : 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태이다.

- <b>준비(Ready)</b>

  - 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태이다.
  - 프로세스는 준비상태 큐에서 실행을 준비하고 있다.
  - 접수 상태에서 준비 상태로 전이는 Job 스케줄러에 의해 수행된다.

- <b>실행(Run)</b>

  - 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태이다.
  - 프로세스 수행이 완료되기 전에 프로세스에게 주어진 프로세서 할당 시간이 종료(Timer Run Out)되면 프로세스는 준비 상태로 전이 된다.
  - 실행중인 프로세스에 입출력 처리가 필요하면 실행중인 프로세스는 대기 상태로 전이 된다.
  - 준비 상태에서 실행 상태로의 전이는 CPU(프로세서) 스케줄러에 의해 수행된다.

- <b>대기(Wait), 보류, 블록(Block)</b>

  : 프로세스에 입출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입출력 처리가 완료될 때까지 대기하고 있는 상태이다.

- <b>종료(Terminated, Exit)</b>

  : 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태이다.



### 프로세스 상태 전이 관련 용어

- <b>Dispatch</b>

  : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정이다.

- <b>Wake Up</b>

  : 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이 되는 과정이다.

- <b>Spooling</b>

  : 입출력장치의 공유 및 상대적으로 느린 입출력장치의 처리 속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입출력할 데이터를 직접 입출력장치에 보내지 않고 나중에 한꺼번에 입출력하기 위해 디스크에 저장하는 과정이다,

- <b>교통량 제어기(Traffic Controller)</b>

  : 프로세스의 상태에 대한 조사와 통보를 담당한다.



### 스레드(Thread)

: 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위이다.

- 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 한다.
- 프로세스의 일부 특성을 갖고 있기 때문에 경량(Light Weight) 프로세스라고도 한다.
- 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다.
- 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능하다.
- <b>스레드 분류</b>
  - 사용자 수준의 스레드
    - 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.
    - 속도는 빠르지만 구현이 어렵다.
  - 커널 수준의 스레드
    - 운영체제의 커널에 의해 스레드를 운용한다.
    - 구현이 쉽지만 속도가 느리다.
- <b>스레드 사용의 장점</b>
  - 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있다.
  - 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.
  - 응용 프로그램의 응답시간을 단축시킬 수 있다.
  - 실행 환경을 공유시켜 기억장소의 낭비가 줄어든다.
  - 프로세스들 간의 통신이 향상된다.
  - 스레드는 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다.



## 149) 스케줄링(B)

### 스케줄링(Scheduling)의 개요

: 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업을 의미

- 프로세스가 생성되어 완료될 때까지 프로세스는 여러 종류의 스케줄링 과정을 거치게 된다.

- 스케줄링의 종류

  - 장기 스케줄링
    - 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업을 의미
    - 작업 스케줄링, 상위 스케줄링이라고도 하며, 작업 스케줄러에 의해 수행
  - 중기 스케줄링
    - 어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업을 의미
    - CPU를 할당받으려는 프로세스가 많을 경우 프로세스를 일시 보류시킨 후 활성화해서 일시적으로 부하를 조절
  - 단기 스케줄링
    - 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업을 의미
    - 프로세서 스케줄링, 하위 스케줄링이라고도 한다.
    - 프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행

- 문맥 교환(Context Switching)

  : 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것으로 새로운 프로세스에 CPU를 할당하기 위해 현재 CPU가 할당된 프로세스의 상태 정보를 저장하고, 새로운 프로세스의 상태 정보를 설정한 후 CPU를 할당하여 실행되도록 하는 작업을 의미



### 스케줄링의 목적

: CPU나 자원을 효율적으로 사용하기 위한 정책

- <b>공정성</b>

  : 모든 프로세스에 공정하게 할당한다.

- <b>처리율(량) 증가</b>

  : 단위 시간당 프로세스를 처리하는 비율(양)을 증가시킨다.

- <b>CPU 이용률 증가</b>

  : 프로세스 실행 과정에서 주기억장치를 액세스한다든지, 입출력 명령 실행 등의 원인에 의해 발생할 수 있는 CPU의 낭비 시간을 줄이고, CPU가 순수하게 프로세스를 실행하는데 사용되는 시간 비율을 증가시킨다.

- <b>우선순위 제도</b>

  : 우선순위가 높은 프로세스를 먼저 실행한다.

- <b>오버헤드 최소화</b>

  : 오버헤드를 최소화 한다.

- <b>응답 시간(Response Time, 반응시간) 최소화</b>

  : 작업을 지시하고, 반응하기 시작하는 시간을 최소화

- <b>반환 시간(Turn Around Time) 최소화</b>

  : 프로세스를 제출한 시간부터 실행이 완료될 때까지 걸리는 시간을 최소화 한다.

- <b>대기 시간 최소화</b>

  : 프로세스가 준비상태 큐에서 대기하는 시간을 최소화 한다.

- <b>균형 있는 자원의 사용</b>

  : 메모리, 입출력장치 등의 자원을 균형있게 사용한다.

- <b>무한 연기 회피</b>

  : 자원을 사용하기 위해 무한정 연기되는 상태를 회피한다.

#### 스케줄링의 성능 평가 기준

: 스케줄링의 목적 중 CPU 이용률, 처리율, 반환 시간, 대기 시간, 응답 시간,  균형있는 자원의 활용은 여러 종류의 스케줄링 성능을 비교하는 기준이된다.



### 프로세스 스케줄링의 기법

#### 비선점(Non-Preemptive) 스케줄링

- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
- 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용
- 모든 프로세스에 대한 요구를 공정하게 처리할 수 있다.
- 프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합
- 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있다.
- 비선점 스케줄링의 종류에는 FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘이 있다.

#### 선점(Preemptive) 스케줄링

- 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법이다.
- 우선순위가 높은 프로세스를 빠르게 처리할 수 있다.
- 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용
- 많은 오버헤드를 초래한다.
- 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록(Clock)이 필요하다.
- 선점 스케줄링의 종류에는 Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘이 있다.



## 150) 환경 변수(C)

### 환경 변수(Environment Variable)의 개요

: 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임을 의미

- 변수명과 값으로 구성
- 시스템의 기본 정보를 저장
- 자식 프로세스에 상속
- 시스템 전반에 걸쳐 적용되는 시스템 환경 변수와 사용자 계정 내에서만 적용되는 사용자 환경 변수로 구분



### Windows의 주요 환경 변수

: Windows에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞뒤에 %를 입력해야 한다.

| 환경 변수         | 용도                                          |
| ----------------- | --------------------------------------------- |
| %ALLUSERPROFILE%  | - 모든 사용자의 프로필이 저장된 폴더          |
| %APPDATA%         | - 설치된 프로그램의 필요 데이터가 저장된 폴더 |
| %ComSpec%         | - 기본 명령 프롬프토로 사용할 프로그램명      |
| %HOMEDRIVE%       | - 로그인한 계정의 정보가 저장된 드라이브      |
| %HOMEPATH%        | - 로그인한 계정의 기본 폴더                   |
| %LOGONSERVER%     | - 로그인한 계정이 접속한 서버명               |
| %PATH%            | - 실행 파일을 찾는 경로                       |
| %PATHEXT%         | - cmd에서 실행할 수 있는 파일의 확장자 목록   |
| %PROGRAMFILES%    | - 기본 프로그램의 설치 폴더                   |
| %SYSTEMDRIVE%     | - Windows가 부팅된 드라이브                   |
| %SYSTEMROOT%      | - 부팅된 운영체제가 들어 있는 폴더            |
| %TEMP% 또는 %TMP% | - 임시 파일이 저장되는 폴더                   |
| %USERDOMAIN%      | - 로그인한 시스템의 도메인명                  |
| %USERNAME%        | - 로그인한 계정 이름                          |
| %USERPROFILE%     | - 로그인한 유저의 프로필이 저장된 폴더명      |

- Windows에서 set을 입력하면 모든 환경 변수와 값을 표시



### UNIX / LINUX의 주요 환경 변수

: UNIX나 LINUX에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞에 $를 입력해야 한다.

| 환경 변수 | 용도                                        |
| --------- | ------------------------------------------- |
| $DISPLAY  | - 현재 X 윈도 디스플레이 위치               |
| $HOME     | - 사용자의 홈 디렉터리                      |
| $LANG     | - 프로그램 사용 시 기본적으로 지원되는 언어 |
| $MAIL     | - 메일을 보관하는 경로                      |
| $PATH     | - 실행 파일을 찾는 경로                     |
| $PS1      | - 쉘 프롬프트 정보                          |
| $PWD      | - 현재 작업하는 디렉터리                    |
| $TERM     | - 로긴 터미널 타입                          |
| $USER     | - 사용자의 이름                             |

- UNIX와 LINUX에서 set, env, printenv 중 하나를 입력하면 모든 환경 변수와 값을 표시



## 151) 운영체제 기본 명령어(B)

### 운영체제 기본 명령어의 개요

- 운영체제를 제어하는 방법은 크게 CLI와 GUI로 구분할 수 있다.
- CLI(Command Line Interface)는 키보드로 명령어를 직접 입력하여 작업을 수행하는 사용자 인터페이스
- GUI(Graphic User Interface)는 마우스로 아이콘이나 메뉴를 선택하여 작업을 수행하는 그래픽 사용자 인터페이스



### Windows 기본 명령어

#### CLI 기본 명령어

: 명령 프롬프트(Command) 창에 명령어를 입력하여 작업을 수행하는 것

| 명령어 | 기능                                        |
| ------ | ------------------------------------------- |
| DIR    | - 파일 목록을 표시                          |
| COPY   | - 파일을 복사                               |
| TYPE   | - 파일의 내용을 표시                        |
| REN    | - 파일의 이름을 변경                        |
| DEL    | - 파일을 삭제                               |
| MD     | - 디렉터리를 생성                           |
| CD     | - 디렉터리 위치를 변경                      |
| CLS    | - 화면의 내용을 지운다.                     |
| ATTRIB | - 파일의 속성을 변경                        |
| FIND   | - 파일을 찾는다                             |
| CHKDSK | - 디스크 상태를 점검                        |
| FORMAT | - 디스크 표면을 트랙과 섹터로 나누어 초기화 |
| MOVE   | - 파일을 이동                               |

#### GUI 기본 명령어

: 바탕 화면이나 Windows 탐색기에서 마우스로 아이콘을 더블클릭하여 프로그램 실행, 파일의 복사 및 이동, 제어판의 기능 실행 등 모든 작업이 GUI의 명령어에 해당



### UNIX / LINUX 기본 명령어

#### CLI 기본 명령어

: 쉘에 명령어를 입력하여 작업을 수행하는 것

| 명령어        | 기능                                                         |
| ------------- | ------------------------------------------------------------ |
| cat           | - 파일 내용을 화면에 표시                                    |
| chdir         | - 현재 사용할 디렉터리의 위치를 변경                         |
| chmod         | - 파일의 보호 모드를 설정하여 파일의 사용 허가를 지정        |
| chown         | - 소유자를 변경                                              |
| cp            | - 파일을 복사                                                |
| exec          | - 새로운 프로세스를 수행                                     |
| find          | - 파일을 찾는다.                                             |
| fork          | - 새로운 프로세스를 생성한다(하위 프로세스 호출, 프로세스 복제 명령) |
| fsck          | - 파일 시스템을 검사하고 보수한다.                           |
| getpid        | - 자신의 프로세스 아이디를 얻는다.                           |
| getppid       | - 부모 프로세스 아이디를 얻는다.                             |
| ls            | - 현재 디렉터리 내의 파일 목록을 확인                        |
| mount/unmount | - 파일 시스템을 마운팅(서브 디렉터리 연결) 및 해재한다.      |
| rm            | - 파일을 삭제한다.                                           |
| wait          | - fork 후 exec에 의해 실행되는 프로세스의 상위프로세스가 하위 프로세스 종료 등의 event를 기다린다. |

#### GUI 기본 명령어

: UNIX와 LINUX는 기본적으로 CLI를 기반으로 운영되는 시스템이지만 X Windows라는 별도의 프로그램을 설치하여 GUI 방식으로 운영할 수 있다.



## 152) 인터넷(A)

### 인터넷(Internet)의 개요

: TCP/IP 프로토콜을 기반으로 하여 전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망

- 유닉스 운영체제를 기반으로 한다.
- 통신망과 컴퓨터가 있는 곳이라면 시간과 장소에 구애받지 안혹 정보를 교환할 수 있다.
- 인터넷에 연결된 모든 컴퓨터는 고유한 IP 주소를 갖는다.
- 컴퓨터 또는 네트워크를 서로 연결하기 위해서는 브리지, 라우터, 게이트웨이가 사용된다.
  - 브리지, 라우터, 게이트웨이는 네트워크를 연결하기 위한 장비이다.
- 다른 네트워크 또는 같은 네트워크를 연결하여 중추적 역할을 하는 네트워크로, 보통 인터넷의 주가 되는 기간망을 일컫는 것을 백본(Backbone) 이라고 한다.



### IP 주소(Internet Protocol Address)

: 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.

- 숫자는 8비트씩 4부분, 총 32비트로 구성
- 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성
  - A Class
    - 국가나 대형 통신망에 사용(0~127로 시작)
    - 2^24 = 16,777,216개의 호스트 사용 가능
  - B Class
    - 중대형 통신망에 사용(128~191로 시작)
    - 2^16 = 65,536개의 호스트 사용 가능
  - C Class
    - 소규모 통신망에 사용(192~223으로 시작)
    - 2^8 = 256개의 호스트 사용 가능
  - D Class
    - 멀티 캐스트용으로 사용(224~239로 시작)
    - 멀티 캐스트 : 한 명 이상의 송신자들이 특정한 한 명 이상의 수신자들에게 데이터를 전송하는 방식
  - E Class
    - 실험적 주소이며 공용되지 않음



### 서브네팅(Subnetting)

: 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것을 의미

- 서브넷 마스크 : 네트워크 ID와 호스트 ID를 구별하는 방식

- 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용
- 서브넷 마스크는 각 클래스마다 다르게 사용



### IPv6(Internet Protocol version 6)

: 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발

- 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있으며, IPv4에 비해 자료 전송 속도가 빠르다.
- 인증성, 기밀성, 데이터의 무결성의 지원으로 보안 문제를 해결할 수 있다.
- IPv4와 호환성이 뛰어나다.
- 주소의 확장성, 융통성, 연동성이 뛰어나며, 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원
- Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장이 용이



### IPv6의 구성

- 16비트씩 8부분, 총 128비트로 구성
- 각 부분은 16진수로 표현하고, 콜론(:)으로 구분
- IPv6의 세 가지 체계
  - 유니캐스트(Unicast) : 단일 송신자와 단일 수신자 간의 통신(1 대 1 통신에 사용)
  - 멀티캐스트(Multicast) : 단일 송신자와 다중 수신자 간의 통신(1 대 다 통신에 사용)
  - 애니케스트(Anycast) : 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신(1 대 1 통신에 사용)



### 도메인 네임(Domain Name)

: 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것

- 호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관의 종류, 소속 국가명 순으로 구성되며, 왼쪽에서 오른쪽으로 갈수록 상위 도메인을 의미
  - 도메인 네임의 구성 : www(호스트 컴퓨터 이름).sinagong(소속 기관 이름).co(소속 기관 종류).kr(소속 국가)
- 문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)라고 하며 이런 역할을 하는 서버를 DNS라고 한다.



## 153) OSI 참조 모델(A)

### OSI(Open System Interconnection) 참조 모델의 개요

: 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)이다.

- 개방현 시스템(Open System) 간의 데이터 통신 시 필요한 장비 및 처리 방법등을 7단계로 표준화하여 규정했다.
- OSI 7계층은 1~3 계층을 하위 계층, 4~7 계층을 사우이 계층이라고 한다.
  - 하위 계층 : 물리 계층 >> 데이터 링크 계층 >> 네트워크 계층
  - 상위 계층 : 전송 계층 >> 세션 계층 >> 표현 계층 >> 응용 계층



### OSI 참조 모델의 목적

- 서로 다른 시스템 간을 상호 접속하기 위한 개념을 규정
- OSI 규정을 개발하기 위한 범위를 정함
- 관련 규정의 적합성을 조절하기 위한 공통적 기반을 제공



### OSI 참조 모델에서의 데이터 단위

#### 프로토콜 데이터 단위(PDU; Protocol Data Unit)

- <b>물리 계층</b> : 비트
- <b>데이터 링크 계층</b> : 프레임
- <b>네트워크 계층</b> : 패킷
- <b>전송 계층</b> : 세그먼트
- <b>세션, 표현, 응용 계층</b> : 메세지

#### 서비스 데이터 단위(SDU; Service Data Unit)

: 서비스 접근점(SAP)을 통해 상하위 계층끼리 주고받는 정보의 단위

- 서비스 접근점 : 상위 계층이 자신의 하위 계층으로부터 서비스를 제공받는 점



#### 물리 계층(Physical Layer)

: 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의

- <b>관련 장비</b> : 리피터, 허브



### 데이터 링크 계층(Data Link Layer)

: 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 하낟.

- 송신 측과 수신 측의 속도 차이를 해결하기 위한 <b>흐름 제어</b> 기능을 한다.
- 프레임의 시작과 끝을 구분하기 위한 <b>프레임 동기화</b> 기능을 한다.
- 오류의 검출과 회복을 위한 <b>오류 제어</b> 기능을 한다.
- 프레임의 순서적 전송을 위한 <b>순서 제어</b> 기능을 한다.
- HDLC, LAPB, LLC, MAC, LAPD, PPP 등의 표준이 있다.
- <b>관련 장비</b> : 랜카드, 브리지, 스위치



#### 네트워크 계층(Networ Layer, 망 계층)

: 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 한다.

- 네트워크 연결을 설정, 유지, 해재하는 기능을 한다.
- 경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행
- X, 25, IP 등의 표준이 있다.
- <b>관련 장비</b> : 라우터



### 전송 계층(Transport Layer)

: 논리적 안정과 균일한 데이터 전송을 제공함으로써 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능하게 한다.

- OSI 7계층 중 하위 3계층과 상위 3계층의 인터페이스를 담당
- 종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능을 한다.
- 주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행
- TCP, UDP 등의 표준이 있다.
- <b>관련 장비</b> : 게이트웨이



### 세션 계층(Session Layer)

: 송수신 측 간의 관련성을 유지하고 <b>대화 제어</b>를 담당

- 대화(회화) 구성 및 동기 제어, 데이터 교환 관리 기능을 한다.
- 송수신 측 간의 대화 동기를 위해 전송하는 정보의  일정한 부분에 체크점을 두어 정보의 수신 상태를 체크하며, 이때의 체크점을 동기점이라고 한다.
- 동기점은 오류가 있는 데이터의 회복을 위해 사용하는 것으로, 종류에는 소동기점과 대동기 점이 있따.



### 표현 계층(Presentation Layer)

: 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변화하는 기능을 한다.

- 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층
- 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포맷) 변환, 문맥 관리 기능을 한다.



### 응용 계층(Applcation Layer)

: 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공한다.

- 응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스를 제공한다.



## 154) 네트워크 관련 장비(B)

### 네트워크 인터페이스 카드(NIC; Network Interface Card)

: 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치로, 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경한다.

- 이더넷 카드(LAN 카드) 혹은 네트워크 어댑터라고도 한다.



### 허브(Hub)

: 한 사무실이나 가까운 거리의 컴퓨터를 연결하는 장치로, 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하느 ㄴ리피터의 역할도 포함한다.

- 허브의 종류에는 더미 허브, 스위칭 허브가 있다.
- 더미 허브(Dummy Hub)
  - 네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만을 제공
  - LAN이 보유한 대역폭을 컴퓨터 수만큼 나누어 제공
  - 네트워크에 연결된 각 노드를 물리적인 성형 구조로 연결
- <b>스위칭 허버(Switching Hub)</b>
  - 네트워크상에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 허브의 최대 대역폭을 사용할 수 있는 지능형 허브이다.
  - 최근에 사용되는 허브는 대부분 스위칭 허브이다.



### 리피터(Repeater)

: 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행

- OSI 참조 모델의 물리 계층에서 동작하는 장비
- 근접한 네트워크 사이에 신호를 전송하는 역할로, 전송 거리의 연장 또는 배선의 자유도를 높이기 위한 용도로 사용



### 브리지(Bridge)

: LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹(세그먼트)을 연결하는 기능을 수행

- 데이터 링크 계층 중 MAC(Media Access Control) 계층에서 사용되므로 MAC 브리지라고도 한다.
- 네트워크 상의 많은 단말기들에 의해 발생되는 트래픽 병목 현상을 줄일 수 있다.
- 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있다.
- 브리지를 서브넷 구성 시 전송 가능한 회선 수는 브리지가 n개일 때, n(n-1)/2개 이다.



### 스위치(Switch)

: 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치이다.

- 하드웨어를 기반으로 처리하므로 전송 속도가 빠르다.
- 포트마다 각기 다른 전송 속도를 지원하도록 제어할 수 있고, 수십에서 수백 개의 포트를 제공
- OSI 참조 모델의 데이터 링크 계층에서 사용



### 라우터(Router)

: 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것으로, 서로 다른 LAN이나 LAN과 WAN의 연결도 수행한다.

- OSI 참조 모델의 네트워크 계층에서 동작하는 장비이다.
- 접속 가능한 경로에 대한 정보를 라우팅 제어표에 저장하여 보관한다.
- 3계층(네트워크 계층)까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행



### 게이트웨이(Gateway)

: 전 계층(1~7 계층)의 프로토콜 구조가 다른 네트워크의 연결을 수행

- 세션 계층, 표현 계층, 응용 계층 간을 연결하여 데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행
- LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 한다.



### 네트워크 장비 설치 시 고려 사항

- 네트워크에 설치된 장비를 최대한 활용해야 한다.
- 이후 시스템 확장이나 증설 등을 고려하여 설계한다.
- 하드웨어와 소프트웨어는 최신 버전을 선정
- 트래픽을 분산시킬 수 있도록 설계
- 네트워크 관리나 유지 보수가 용이하게 설계
- 장애 발생 시 즉시 조치할 수 있도록 여유 포트를 고려하여 설계
- 신기술 도입 시 연동할 수 있는 미래 지향적인 네트워크 시스템을 구축



## 155) 프로토콜의 개념(B)

: 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜 놓은 통신 규약

- 통신을 제어하기 위한 표준 규칙과 절차의 집합으로 하드웨어와 소프트웨어, 문서를 모두 규정



### 프로토콜의 기본 요소

- <b>구문(Syntax)</b> : 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정
- <b>의미(Semantics)</b> : 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보 규정
- <b>시간(Timing)</b> : 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정



### 프로토콜의 기능

- 단편화와 재결합
  - 송신 측에서 전송할 데이터를 전송에 알맞은 일정 크기의 작은 블록으로 자르는 작업을 단편화라고 하고, 수신 측에서 단편화된 블록을 데이터로 모으는 것을 재결합 이라 한다.
  - 단편화를 통해 세분화된 데이터 블록을 프로토콜 데이터 단위(PDU; Protocol Data Unit)라고 한다.
  - 데이터를 단편화 하여 전송하면 전송 시간이 빠르고, 통신중의 오류를 효과적으로 제어할 수 있다.
  - 너무 작은 블록으로 단편화할 경우 재결합 시 처리 시간이 길어지고 ,실제 데이터 외에 부수적인 데이터가 많아지므로 비효율적이다.
- 캡슐화
  - 단편화 된 송수신지 주소, 오류 검출 코드, 프로토콜 기능을 구현하기 위한 프로토콜 제어 정보 등의 정보를 부가하는 것으로, 요약화라고도 한다.
  - 대표적인 예가 데이터 링크 제어 프로토콜의 HDLC 프레임이다.
  - 정보 데이터를 오류 없이 정확하게 전송하기 위해 캡슐화를 수행한다.
- 흐름 제어
  - 흐름 제어는 수신 측의 처리 능력에 따라 송신 측에서 송신하는 데이터의 전송량이나 전송 속도를 조절하는 기능이다.
  - 정지-대기, 슬라이딩 윈도우 방식을 이용한다.
- 동기화
  - 송수신 측이 같은 상태를 유지하도록 타이밍을 맞추는 기능이다.
- 순서 제어
  - 전송되는 데이터 블록에 전송 순서를 부여하는 기능으로, 연결 위주의 데이터 전송 방식에만 사용
  - 송신 데이터 들이 순서적으로 전송되도록 함으로써 흐름 제어 및 오류 제어를 용이하게 하는 기능을 한다.
- 주소 지정
  - 데이터가 목적지 까지 정확하게 전송될 수 있도록 목적지 이름, 주소, 경로를 부여하는 기능이다.
  - 목적지 이름은 전송할 데이터가 가리키는 곳, 주소는 목적지의 위치, 경로는 목적지에 도착할 수 있는 방법을 의미
- 다중화
  - 한 개의 통신 회선을 여러 가입자들이 동시에 사용하도록 하는 기능
- 경로 제어
  - 송수신 측 간의 송신 경로 중에서 최적의 패킷 교환 경로를 설정하는 기능
- 전송 서비스
  - 전송하려는 데이터가 사용하도록 하는 별도의 부가 서비스이다.
  - <b>우선 순위</b> : 빠르게 전송하기 위해 메시지 단위에 우선순위를 부여하여 우선순위가 높은 메시지가 먼저 도착하도록 한다.
  - <b>서비스 등급</b> : 데이터의 요구에 따라 서비스 등급을 부여하는 서비스
  - <b>보안성</b> : 액세스 제한과 같은 보안 체제를 구현



## 156) TCP / IP (A)

### TCP/IP의 개요(Transmission Control Protocol/Internet Protocol)

: 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜이다.

- UNIX의 기본 프로토콜로 사용되었고, 현재 인터넷 범용 프로토콜로 사용된다.
- TCP/IP는 다음과 같은 기능을 수행하는 TCP프로토콜과 IP 프로토콜이 결홥된 것을 의미
  - TCP
    - OSI 7계층의 전송 계층에 해당
    - 신뢰성 있는 연결형 서비스 제공
    - 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공
    - 스트림 전송 기능 제공
    - TCP 헤더에는 Source/Destination Port Number, Sequence Number, Acknowledgment Number, Checksum 등이 포함
  - IP
    - OSI 7계층의 네트워크 계층에 해당
    - 데이터그램을 기반으로 하는 비연결형 서비스 제공
    - 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공
    - 헤더의 길이는 최소 20Byte에서 최대 60Byte이다.
    - IP 헤더에는 Version, Header Length, Total Packet Length, Header Checksum, Source IP Address, Destiation IP Address 등이 포함



### TCP/IP의 구조

| OSI                    | TCP/IP               | rlsmd                                                        |
| ---------------------- | -------------------- | ------------------------------------------------------------ |
| 응용, 표현, 세션 계층  | 응용 계층            | - 응용 프로그램 간의 데이터 송수신 제공<br />- TELNET, FTP, SMTP, SNMP, DNS, HTTP 등 |
| 전송 계층              | 전송 계층            | - 호스트들 간의 신뢰성 있는 통신 제공<br />- TCP, UDP        |
| 네트워크 계층          | 인터넷 계층          | - 데이터 전송을 위한 주소 지정, 경로 설정을 제공<br />- IP, ICMP, IGMP, ARP, RARP |
| 데이터 링크, 물리 계층 | 네트워크 액세스 게층 | - 실제 데이터(프레임)를 송수신하는 역할<br />- Ethernet, IEEE 802, HDLC, X.25, RS-232C, ARQ 등 |



### 응용 계층의 주요 프로토콜

- FTP(File Transfer Protocol)
  - 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원결 파일 전송 프로토콜
- SMTP(Simple Mail Transfer Protocol)
  - 전자 우편을 교환하는 서비스
- TELNET
  - 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스
  - 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널 기능을 수행
- SNMP(Simple Network Management Protocol)
  - TCP/IP의 네트워크 관리 프로토콜로, 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용되는 표준 통신 규약
- DNS(Domain Name System)
  - 도메인 네임을 IP 주소로 매핑하는 시스템
- HTTP(Hyper Text Transfer Protocol)
  - 월드 와이드 웹에서 HTML 문서를 송수신 하기 위한 표준 프로토콜



### 전송 계층의 주요 프로토콜

- TCP(Transmission Control Protocol)
  - 양방향 연결형 서비스를 제공
  - 가상 회선 연결 형태의 서비스를 제공
  - 스트림 위주의 전달(패킷 단위)
  - 신뢰성 있는 경로를 확립하고 메시지 전송을 감독
  - 순서 제어, 오류 제어, 흐름 제어 기능을 한다.
  - 패킷의 분실, 손상, 지연이나 순서가 틀린 것 등이 발생할 떄 투명성이 보장되는 통신을 제공
- UDP(User Datagram Protocol)
  - 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공
  - TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로, 오버헤드가 적다.
  - 고속의 안정성 있는 전송 매체를 사용하여 빠른 속돌르 필요로 하는 경우, 동시에 여러 사용자에게 데이터를 전달할 경우, 정기적으로 반복해서 전송할 경우 사용
  - 실시간 전송에 유리하며, 신뢰성 보다는 속도가 중요시되는 네트워크에서 사용
  - UDP 헤더에는 Source Port Number, Destination Port Number, Length, Checksum 등이 포함
- RTCP(Real-Time Control Protocol)
  - RTP패킷의 전송 품질을 제어하기 위한 제어 프로토콜
  - 세션에 참여한 각 참여자들에게 주기적으로 제어 정보를 전송
  - 하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화를 제공
  - 데이터 전송은 모니터링하고 최소한의 제어와 인증 기능만을 제공
  - RTCP 패킷은 항상 32비트의 경계로 끝난다.



### 인터넷 계층의 프로토콜

- IP(Internet Protocol)
  - 전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능
  - 비연결형인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않는다.
- ICMP(Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜)
  - IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 하며, 헤더는 8Byte로 구성
- IGMP(Internet Group Management Protocol, 인터넷 그룹 관리 프로토콜)
  - 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용
- ARP(Address Resolution Protocol, 주소 분석 프로토콜)
  - 호스트 IP주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 바꾼다
- RARP(Reverse Address Resolution Protocol)
  - ARP와 반대로 물리적 주소를 IP 주소로 변환하는 기능을 한다.



### 네트워크 액세스 계층의 주요 프로토콜

- Ethernet(IEEE 802.3) : CSMA/CD 방식의 LAN
- IEEE 802 : LAN을 위한 표준 프로토콜
- HDLC : 비트 위주의 데이터 링크 제어 프로토콜
- X.25 : 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜
- RS-232C : 공중 전화 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜

