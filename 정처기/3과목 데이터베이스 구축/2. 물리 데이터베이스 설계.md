# 2. 물리 데이터베이스 설계

## 85) 사전 조사 분석(B)

### 물리 데이터베이스 설계

: 논리적 구조로 표현된 논리적 데이터베이스를 디스크 등의 물리적 저장정치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정

- 물리 데이터베이스 구조의 기본적인 데이터 단위는 저장 레코드(Stored Record)이다.

- 물리적 설계 단계에서 꼭 포함되어야 할 것은 저장 레코드의 양식 설계, 레코드 집중(Record Clustering)의 분석 및 설계 , 접근 경로 설계 등이다.

- 여러 가지 타입의 저장 레코드 집합이라는 면에서 단순한 파이로가 다르다.

- 데이터 베이스 시스템의 성능에 중대한 영향을 미친다

- 물리적 설계 시 고려 사항

  - 인덱스 구조
  - 레코드 크기
  - 파일에 존재하는 레코드 개수
  - 파일에 대한 트랜잭션의 갱신과 참조 성향
  - 성능 향상을 위한 개념 스키마의 변경 여부 검토
  - 빈번한 질의와 트랜잭션들의 수행속도를 높이기 위한 고려
  - 시스템 운용 시 파일 크기의 변화 가능성

- 물리적 설계 전에 기존 시스템을 분석하여 데이터 명명 규칙, 시스템 자원, 데이터 베이스 관리 요소 등을 파악해야 한다.

- 물리적 설계 옵션

  - 반응 시간(Response Time)

    : 트랜잭션 수행을 요구한 시점부터 처리 결과를 얻을때까지의 경과 시간

  - 공간 활용도(Space Utilzation)

    : 데이터베이스 파일과 액세스 경로 구조에 의해 사용되는 저장 공간의 양

  - 트랜잭션 처리량(Transaction Throughput)

    : 단위시간 동안 데이터베이스 시스템에 의해 처리될 수 있는 트랜잭션의 평균 개수



### 데이터 명명 규칙 파악

: 물리 데이터 모델에 적용해야 하는 규칙으로, 조직마다 다를 수 있으므로 물리 데이터 모델의 설계 전에 파악해야 한다.

- 데이터 표준화 및 논리 데이터베이스 설계의 결과물 등을 통해 파악

- 물리 데이터베이스 설계와 논리 데이터베이스 설계에 적용되는 명명 규칙은 서로 일관성을 유지해야 한다.

- 논리적 데이터 요소를 물리적 데이터 요소로 전환할 떄 동일 명칭 부여의 근거로 사용

- 중복 구축 등을 방지할 수 있다.

- 도메인과 데이터 사전에 대한 지식이 필요

- <b>도메인</b>

  : 객체에 포함된 속성들의 데이터 타입, 크기 등을 표준화 규칙에 따라 일관성 있게 정의한 것을 의미

- <b>데이터 사전(데이터 용어 사전)</b>

  - 전체 프로젝트 과정에서 일관성 있는 데이터 이름과 인터페이스를 제공하기 위해 데이터 속성의 논리명(Logical Name), 물리명(Physical Name), 용어 정의(Definition)를 기술해 놓은 것이다.
  - 데이터 사전은 프로젝트에서 사용하는 명칭 부여의 근거로 사용



### 시스템 자원 파악

: 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소들로, 사전에 미리 파악해야 한다.

- 시스템 자원은 하드웨어 자원, 운영체제 및 DBMS 버전, DBMS 파라미터 정보 등으로 구분한다

#### 하드웨어 자원

- 중앙처리장치

  : 중앙 처리 장치(CPU)의 성능과 집중적인 부하 발생시간 등을 파악

- 메모리

  : 시스템의 전체 메모리 규모, 사용 중인 메모리 영역, 사용 중인 메모리 영역, 사용 가능한 메모리 영역 등 확보된 자원이나 실질적인 시스템 활용 정도 등을 파악

- 디스크

  : 전체 디스크의 크기, 확보된 디스크 자원, 디스크 분할 형태, 현재 디스크 활용률, 사용 가능한 디스크 공간 등을 파악

- I/O Controller

  : 현행 시스템의 입출력 컨트롤러의 성능, 우뇽ㅇ의 적설성 등을 파악

- 네트워크

  : 네트워크의  처리량, 처리 속도, 집중적인 부하 발생 시간, 동시 접속 가능 정도 등을 파악

#### 운영체제 및 DBMS 버전

: 운영체제와 DBMS 버전은 데이터베이스 운영에 영향을 미칠 수 있으므로 관련 요소 등을 파악하고 적절하게 관리해야 한다.

#### DBMS 파라미터(Parameter) 정보

- DBMS 파라미터는 데이터베이스 관리 시스템별로 차이가 많고 관리 방법도 제각각이므로 시스템별 DBMS 파라미터의 종류 및 관리 대상 등을 파악
- DBMS의 저장 공간, 메모리 등에 대한 파라미터, 쿼리에서 활용하는 옵티마이저의 사용방법 등을 파악
  - 옵티마이저 : SQL문을 수행할 가장 효율적이고 빠른 방법을 선택해주는 DBMS의 핵심 엔진



### 데이터베이스 관리 요소 파악

: 데이터베이스 운영과 관련된 관리 요소로, 데이터베이스 시스템의 환경에 따라 달라질 수 있으므로 미리 파악해야 한다.

- 데이터베이스 관리 요소를 파악한 후 이를 기반으로 데이터베이스 시스템 조사 분석서를 작성

- 시스템 조사 분석서를 기반으로 데이터베이스 구조, 이중화 구성, 분산 데이터베이스, 접근제어/접근통제, DB암호화 등의 범위와 특성을 파악

  - 데이터베이스 구조

    : 데이터베이스의 구조에 따라 문제 발생 시 대응방법이 다르므로 서버와 데이터베이스 구조 등을 파악

  - 이중화 구성

    : 문제 발생에 대비하여 동일한 데이터베이스를 복제하여 관리하는 이중화 구성을 파악

  - 분산 데이터베이스

    -  물리적 재해 및 파손 등 데이터 유실을 최소화
    - 장애로 인한 데이터 유실 복구에 효과적이므로 데이터베이스의 분산 구조를 파악

  - 접근 제어/접근 통제

    : 데이터베이스는 접근 가능한 사용자의 권한 남용으로 인한 정보 유출 및 변조가 가장 빈번하게 발생하므로 데이터베이스의 접근 제어 방법 등을 파악

  - DB암호화

    : 데이터 암호화, 암호 키에 대한 인증 등을 통해 데이터 유출 시 데이터의 복호화를 어렵게 하므로 DB암호화의 특성을 파악



## 86) 데이터베이스 저장 공간 설계(B)

### 테이블(Table)

: 데이터베이스의 가장 기본적인 객체로 로우(Row, 행)와 컬럼(Column, 열)으로 구성되어 있다.

- 데이터베이스의 모든 데이터는 테이블에 저장
- 논리 설계 단계의 개체(Entity)에 대응하는 객체
- DBMS 종류에 따라 테이블의 명칭과 기능 등은 약간씩 차이가 있다.
- 테이블의 종류에는 일반 테이블, 클러스터 인덱스 테이블, 파티셔닝 테이블, 외부 테이블, 임시 테이블 등이 있다.



### 일반 테이블

: 현재 사용되는 대부분의 DBMS에서 표준 테이블로 사용되는 테이블 형태

- 저장되는 데이터의 로우 위치는 속성 값에 상관없이 데이터가 저장되는 순서에 따라 결정



### 클러스터드 인덱스 테이블(Clustered Index Table)

: 기본키(Primary Key)나 인덱스키의 순서에 따라 데이터가 저장되는 테이블이다.

- 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축



### 파티셔닝 테이블(Partitioning Table)

: 대용량의 테이블을 작은 논리적 단위인 파티션(Partition)으로 나눈 테이블이다.

- 대용량의 데이터를 효과적으로 관리할 수 있지만 파티션 키를 잘못 구성하면 성능 저하 등의 역효과를 초래할 수 있다.
- 파티셔닝 방식에 따라 범위 분할(Range Partitioning), 해시 분할(Hash Partitioning), 조합 분할(Composite Partitioning) 등으로 나뉜다.
  - 범위 분할 : 지정한 열의 값을 기준으로 분할
  - 해시 분할 : 해시 함수를 적용한 결과 값에 따라 분할
  - 조합 분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식



### 외부 테이블(External Table)

: 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일로, 데이터베이스 내에 객체로 존재

- 데이터웨어하우스(Date Warehouse)에서 ETL(Extraction, Transformation, Loading) 등의 작업에 유용하게 사용



### 임시 테이블(Temporary Table)

: 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블

- 임시 테이블에 저장된 데이터는 트랜잭션이 종료되면 삭제된다.
- 절차적인 처리를 위해 임시로 사용하는 테이블



### 컬럼(Column)

: 테이블의 열을 구성하는 요소로 데이터 타입, 길이 등으로 정의

- 데이터의 일관성 유지를 위해 사용되는 가장 기본적인 것으로, 도메인을 정의한 경우 도메인에 따라 데이터의 타입과 길이가 정의
- 두 컬럼을 비교하는 연산에서 데이터 타입이나 길이가 다르면 DBMS 내부적으로 데이터 타입을 변환한 후 비교 연산을 수행
- 참조 관계인 컬럼들은 데이터 타입과 길이가 일치해야 한다.
- 데이터 타입과 길이 지정 시 고려 사항
  - 가변 길이 데이터 타입 : 예상되는 최대 길이로 정의
  - 고정 길이 데이터 타입 : 최소 길이로 지정
  - 소수점 이하 자릿수 : 소수점 이하 자릿수는 반올림되어 저장
- 데이터 타입에 따른 컬럼의 물리적인 순서
  - 고정 길이 컬럼이고 NOT Null인 컬럼 : 앞쪽
  - 가변 길이 컬럼 : 뒤쪽
  - Null 값이 많을 것으로 예상되는 컬럼 : 뒤쪽



### 테이블스페이스(Tablespace)

: 테이블이 저장되는 논리적인 영역으로, 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장할 수 있다.

- 테이블을 저장하면 논리적으로는 테이블스페이스에 저장되고, 물리적으로는 해당 테이블스페이스와 연관된 데이터 파일에 저장
- 데이터베이스를 테이블, 테이블스페이스, 데이터 파일로 나눠 관리하면 논리적 구성 물리적 구성에 종속되지 않아 투명성이 보장
- 데이터베이스에 저장되는 내용에 따라 테이블, 인덱스, 임시 등으 ㅣ용도로 구분하여 설계
- 테이블스페이스 설계시 고려 사항
  - 업무별로 구분하여 지정
  - 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장
  - 테이블과 인덱스는 분리하여 저장
  - LOB(Large Object) 타입의 데이터는 독립적인 공간으로 지정



## 트랜잭션 분석 / CRUD 분석

### 트랜잭션(Transaction) 정의

: 데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미

- 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용
- 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용



### 트랜잭션의 특징

데이터 무결성을 보장하기 위해 DBMS의 트랜잭션이 가져야할 특성

- Atomicity(원자성)
  - 데이터베이스에 모두 반영되도록 완료되든지 아니면 전혀 반영되지 않도록 복구 되어야 한다.
  - 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
- Comsistency(일관성)
  - 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
  - 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.
- Isoation(독립성, 격리성, 순차성)
  - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
  - 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
- Durability(영속성, 지속성)
  - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.



### CRUD 분석

: 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)를 의미하며, CRUD 분석은 데이터베이스 테이블에 변화를 주는 트랜잭션의 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것

- 테이블에 발생되는 트랜잭션의 주기별 발생 횟수를 파악하고 연관된 테이블들을 분석하면 테이블에 저장되는 데이터의 양을 유추 가능
- 많은 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용 가능
- 외부 프로세스 트랜잭션의 부하가 집중되는 데이터베이스 채널을 파악하고 분산시키으로써 연결 지연이나 타임아웃 오류를 방지할 수 있다.



###  CRUD 매트릭스

: 2차원 형태의 표로서, 행에는 프로세스를, 열에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하는 업무 프로세스와 데이터 간 상관 분셕표이다.

- 프로세스의 트랜잭션이 테이블에 수행하는 작업을 검증
- 각 셀에는 Create, Read, Update, Delete 의 앞글자가 들어가며 복수의 변화를 줄 때는 C>D>U>R의 우선순위를 적용하여 한가지만 적지만, 활용 목적에 따라 모두 기록할 수 있다.
- CRUD 매트릭스 완성 후, 어느 것도 적히지 않은 행이나 열, C나 R이 없는 행을 확인하여 불필요한거나 누락된 테이블 또는 프로세스를 찾는다.



### 트랜잭션 분석

: 트랜잭션 분석의 목적은 CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB 용량을 산정하고 DB 구조를 최적화하는 것이다.

- 업무 개발 담당자가 수행
- 프로세스가 과도하게 접근하는 테이블을 확인하여 여러 디스크에 배치함으로써 디스크 입출력 분산을 통한 성능 향상을 가져올 수 있다.



### 트랜잭션 분석서

: 단위 프로세스와 CRUD 매트릭스를 이용하여 작성하며, 구성 요소에는 단위 프로세스, CRUD 연산, 테이블명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등이 있다.

- <b>단위 프로세스</b>

  : 업무를 발생시키는 가장 작은 단위의 프로세스

- <b>CRUD 연산</b>

  : 프로세스의 트랜잭션이 데이터베이스 테이블에 영향을 주는 C,R,U,D의 4가지 연산

- <b>테이블명, 컬럼명</b>

  : 프로세스가 접근하는 데이터베이스의 테이블명을 기록, 필요한 경우 테이블의 컬럼며을 적는다. 컬럼명을 적을 때는 마침표로 연결하여 '테이블.컬럼명'과 같이 적는다.

- <b>테이블 참조 횟수</b>

  : 프로세스가 테이블을 참조하는 횟수

- <b>트랜잭션 수</b>

  : 주기별로 수행되는 트랜잭션 횟수

- <b>발생 주기</b>

  : 연, 분기, 월, 일, 시간 등 트랜잭션 횟수를 측정하기 위한 발생 주기



## 88) 인덱스 설계(A)

### 인덱스(Index)의 개념

: 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조

- 데이터가 저장된 물리적 구조와 밀접한 관계가 있다.
- 레코드가 저장된 물리적 구조에 접근하는 방법을 제공
- 파일의 레코드에 대한 액세스를 빠르게 수행 가능
- 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는것이 효율적
- 인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 확인하는 TABLE SCAN이 발생
- 기본키를 위한 인덱스를 기본 인덱스라 하고, 기본 인덱스가 아닌 인덱스들을 보조 인덱스라 한다.
- 대부분의 관계형 데이터베이스 관리 시스템에서는 모든 기본키에 대해서 자동적으로 기본 인데스를 생성
- 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터드(Clustered) 인덱스라 한다.
  - 클러스터드 인덱스
    - 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
    - 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있다.
    - 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬해야 한다.
    - 한 개의 릴레이션에 하나의 인덱스만 생성 가능
  - 논클러스터드 인덱스
    - 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
    - 데이터를 검색하기 위해 먼저 인덱스를 검색하여 데이터 위치를 확인해야 하므로 클러스터드 인덱스에 비해 검색 속도가 떨어진다.
    - 한개의 릴레이션에 여러 개의 인덱스를 만들 수 있다.
- 인덱스를 구성하는 구조나 특징에 따라 트리 기반 인덱스, 비트맵 인덱스, 함수 기반 인덱스, 비트맵 조인 인덱스, 도메인 인덱스 등으로 분류



### 트리 기반 인덱스

: 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것으로, 사용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용

- B 트리 인덱스
  - 일반적으로 사용되는 인덱스 방식으로, 루트 노드에서 하위 노드로 키 값의 크기를 비교해 나가면서 단말 노드에서 찾고자 하는 데이터를 검색
  - 키 값과 레코드를 가리키는 포인터들이 트리 노드에 오름차순으로 저장
  - 모든 리프 노드는 같은 레벨에 있다.
- B+ 트리 인덱스
  - B 트리의 변형으로 단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분
  - 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공되며, 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킨다.
  - 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차 처리가 가능



### 비트맵 인덱스

: 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방식

- 키 값을 포함하는 로우의 주소를 제공하는 것이다.
- 분포도가 좋은 컬럼에 적합하며, 성능 향상 효과를 얻을 수 있다.
- 데이터가 Bit로 구성되어 있기 때문에 효율적인 논리 연산이 가능하고 저장 공간이 작다.
- 다중 조건을 만족하는 튜플의 개수 계산에 적합하다.
- 동일한 값이 반복되는 경우가 많아 압축 효율이 좋다.



### 함수 기반 인덱스

: 컬럼의 값 대신 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것으로, B+ 트리 인덱스 또는 비트맴 인덱스를 생성하여 사용

- 데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하가 발생할 수 있다.

- 사용된 함수가 사용자 정의 함수일 경우 시스템 함수보다 부하가 더 크다.

- 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용

- <b>적용 가능한 함수의 종류</b>

  : 산술식(Arithmetic Expression), 사용자 정의 함수, PL/SQL Function, SQL Function, Package, C callout 등



### 비트맵 조인 인덱스

: 다수의 조인된 객체로 구성된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다르다.

- 비트맵 인덱스와 물리적 구조가 동일



### 도메인 인덱스

: 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스(Extensible Index)라고도 한다.

- 개발자가 필요에 의해 만들었지만 프로그램에서 제공하는 인덱스처럼 사용 가능



### 인덱스 설계

: 인덱스를 설계할 때는 분명하게 드러난 컬럼에 대해 기본적인 인덱스를 먼저 지정한 후 개발 단계에서 필요한 인덱스의 설계를 반복적으로 실행

- 인덱스 설계 순서
  1. 인덱스의 대상 테이블이나 컬럼등을 선정
  2. 인덱스의 효율성을 검토하여 인덱스 최적화를 수행
  3. 인덱스 정의서를 작성



### 인덱스 대상 테이블 선정 기준

- MULTI BLOCK READ수에 따라 판단
  - MULTI BLOCK READ : 테이블 액세스 시 메모리에 한 번에 읽어 들일 수 있는 블록의 수를 의미
- 랜덤 액세스가 빈번한 테이블
- 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
- 다른 테이블과 순차적 조인이 발생되는 테이블



### 인덱스 대상 컬럼 선정 기준

- 인덱스 컬럼의 분포도가 10~15% 이내인 컬럼
  - 분포도 = (컬럼값의 평균 로우 수 / 테이블의 총 로우 수) * 100
- 분포도가 10~15% 이상이어도 부분 처리를 목적으로 하는 컬럼
- 입출력 장표 등에서 조회 및 출력 조건으로 사용되는 컬럼
- 인덱스가 자동 생성되는 기본키와 Unique키 제약 조건을 사용한 컬럼
- 가느한 한 수정이 빈번하지 않은 컬럼
- ORDER BY, GROUP BY, UNION이 빈번한 컬럼
- 분포도가 좁은 컬럼은 단독 인덱스로 생성
- 인덱스들이 자주 조합되어 사용되는 경우 하나으 ㅣ결합 인덱스로 생성



### 인덱스 설계 시 고려 사항

- 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있다.
- 인덱스를 지나치게 많이 만들면 오버헤드 발생
- 넓은 버위를 인덱스로 처리하면 많은 오버헤드 발생
- 인덱스를 만들면 추가적인 저장 공간이 필요
- 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계



### 뷰(View) 설계(A)

### 뷰(View)의 개요

: 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이브로부터 유도된, 이름을 가지는 가상 테이블

- 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다.
- 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용
- 조인문의 사용 최소화로 사용상의 편의성을 최대화
- 뷰를 생성하면 뷰 정의가 시스템 내에 저장되었다가 생성된 뷰 이름을 질의어에서 사용할 경우 질의어가 실행될 때 뷰에 정의된 기본 테이블로 대체되어 기본테이블에 대해 실행



### 뷰의 특징

- 기본 테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같다.
- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다.
- 데이터의 논리적 독립성을 제공
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해 진다.
- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용 가능
- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신 연산이 가능
- 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.
- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제



### 뷰의 장단점

- 장점
  - 논리적 데이터 독립성을 제공
  - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응요이나 요구를 지원
  - 사용자의 데이터 관리를 간단하게 해준다.
  - 접근 제어를 통한 자동 보안이 제공
- 단점
  - 독립적인 인덱스를 가질 수 없다.
  - 뷰의 정의를 변경할 수 없다.
  - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다.



### 뷰 설계 순서

1. 대상 테이블을 선정
   - 외부 시스템과 인터페이스에 관여하는 테이블
   - CRUD 매트릭스를 통해 여러 테이블이 동시에 자주 조인되어 접근되는 테이블
   - SQL문 작성 시 거의 모든 문장에서 인라인 뷰(FROM 절 안에 사용되는 서브쿼리) 방식으로 접근되는 테이블
2. 대상 컬럼을 선정
   - 보안을 유지해야 하는 컬럼은 주의하여 선별
3. 정의서를 작성



### 뷰 설계 시 고려 사항

- 테이블 구조가 단순화 될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성
- 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수 있으므로 사용할 데이터를 다양한 관점에서 제시
- 데이터의 보안 유지를 고려하여 설계



## 90) 클러스터 설계(A)

### 클러스터(Cluster)의 개요

: 데이터 저장시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하느 ㄴ물리적 저장 방법

- 크러스터링키로 지정된 컬럼값의 순서대로 저장되고, 여러 개의 테이블이 하나의 클러스터에 저장



### 클러스터의 특징

- 클러스터링 된 테이블은 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하시킨다.
- 데이터 분포도가 넓을수록 유리
- 데이터 분포도가 넓은 테이블을 클러스터링 하면 저장 공간을 절약할 수 있다.
- 클러스팅된 테이블은 클러스터링키 열을 공유하므로 저장 공간이 줄어 든다.
- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋다.
- 처리 범위가 넓은 경우에는 단일 테이블 클러시트링을, 조인이 많이 발생하는 경우에는 다중 테이블 클러스터링을 사용
- 파티셔닝된 테이블에는 클러스터링을 할 수 없다.
- 클러스터링을 하면 비슷한 데이터가 동일한 데이터 블록에 저장되기 때문에 디스크 I/O가 줄어든다.
- 클러스터링된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상된다.



### 클러스터 대상 테이블

- 분포도가 넓은 테이블
- 대량의 범위를 자주 조회하는 테이블
- 입력, 수정, 삭제가 자주 발생하지 않는 테이블
- 자주 조인되어 사용되는 테이블
- ORDER BY, GROUP BY, UNION이 빈번한 테이블



## 91) 파티션 설계(A)

### 파티션(Partition)의 개요

: 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말한다.

- 대용량 DB의 경우 중요한 몇 개의 테이블에만 집중되어 데이터가 증가되므로, 이런 테이블들을 작은 단위로 나눠 분산시키면 서은 저하를 방지할 뿐만 아니라 데이터 관리도 쉬워진다.
- 테이블이나 인덱스를 파티셔닝 하면 파티션키 또는 인덱스키에 따라 물리적으로 별도의 공간에 데이터가 저장
- 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션별로 수행



### 파티션의 장단점

- 장점
  - 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상
  - 파티션 별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상
  - 파티션 별로 백업 및 복구를 수행하므로 속도가 빠름
  - 시스템 장애 시 데이터 손상 정도를 최소화할 수 있다.
  - 데이터 가용성이 향상
  - 파티션 단위로 입출력을 분산
- 단점
  - 하나의 테이블을 세분화하여 관리하므로 세심한 관리가 요구
  - 테이블간 조인에 대한 비용 증가
  - 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하



### 파티션의 종류

: 파티셔닝 방식에 따라 범위 분할, 해시 분할, 조합 분할 등으로 나뉜다

- 범위 분할(Range Partitioning)

  : 지정한 열의 값을 기준으로 분할

  ex) 일별, 월별, 분기별 등

- 해시 분할(Hash Partitioning)

  - 해시 함수를 적용한 결과 값에 따라 데이터 분할
  - 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유용
  - 특정 데이터가 어디에 있는지 판단할 수 없다.
  - 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적

- 조합 분할(Composite Partitioning)

  - 범위 분할로 분할한 후 해시 함수를 적용하여 다시 분할하는 방식
  - 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용



### 파티션키 선정 시 고려 사항

- 파티션키는 테이블 접근 유형에 따라 파티셔닝이 이뤄지도록 선정
- 데이터 관리의 용이성을 위해 이력성 데이터는 파티션 생성주기와 소멸주기를 일치시킴
- 매이 ㄹ생성되는 날짜 컬럼, 백업의 기준이 되는 날짜 컬럼, 파티션 간 이동이 없는 컬럼, I/O 병목을 줄일 수 있는 데이터 분포가 양호한 컬럼 등을 파티션키로 선정



### 인덱스 파티션

: 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것

- 파티션된 테이블의 종속 여부에 따라 Local Partitioned Index와 Global Partitioned Index로 나뉜다.

  - Local Partitioned Index

    : 테이블 파티션과 인덱스 파티션이 1:1 대응되도록 파티셔닝

  - Global Partitioned Index

    : 테이블 파티션과 인덱스 파티션의 독립적으로 구성되도록 파티셔닝

  - Local Partitioned Index가 Global Partitioned Index에 비해 데이터 관리가 쉽다.

- 인덱스 파티션은 인덱스 파티션키 컬럼의 위치에 따라 Prefixed Partitioned Index와 Non-prefixed Partitioned Index로 나뉜다.

  - Prefixed Partitioned Index

    : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 같다.

  - Non-prefixed Partitioned Index

    : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 다르다.

- Local, Gloabal, Prefixed, Non-prefixed를 조합하여 구분하기도 한다.



## 93) 분산 데이터베이스 설계(A)

### 분산 데이터베이스 정의

: 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스를 말한다.

- 데이터의 처리나 이용이 많은 지역에 데이터베이스를 위치시킴으로써 데이터의 처리가 가능한 해당 지역에서 해결될 수 있도록 한다.



### 분산 데이터베이스의 구성 요소

- 분산 처리기

  : 자체적으로 처리 능력을 가지며, 지리적으로 분산되어 있는 컴퓨터 시스템을 말한다.

- 분산 데이터베이스

  : 지리적으로 분산되어 있는 데이터베이스로서 해당 지역의 특성에 맞게 데이터베이스가 구성된다.

- 통신 네트워크

  : 분산 처리기들을 통신망으로 연결하여 논리적으로 하나의 시스템처럼 자동할 수 있도록 하는 통신 네트워크를 말한다.



### 분산 데이터베이스 설계 시 고려 사항

- 작업부하의 노드별 분산 정책
- 지역의 자치성 보장 정책
- 데이터의 일관성 정책
- 사이트나 회선의 고장으로부터의 회복 기능
- 통신 네트워크를 통한 원격 접근 가능



### 분산데이터베이스의 목표

#### 위치 투명성(Location Transparency)

: 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있다.

#### 중복 투명성(Replication Transparency)

: 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행

#### 병행 투명성(Concurrency Transparency)

: 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.

#### 장애 투명성(Failure Transparency)

: 트랜잭션, DBMA, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리



### 분산 데이터베이스의 장단점

- 장점
  - 지역 자치성이 높다.
  - 자료의 공유성이 향상
  - 분산 제어가 가능
  - 시스템 성능이 향상
  - 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않는다.
  - 효용성과 융통성의 높다.
  - 신뢰성 및 가용성이 높다.
  - 점진적 시스템 용량 확장이 용이
- 단점
  - DBMS가 수행할 기능이 복잡하다.
  - 데이터베이스 설계가 어렵다.
  - 소프트웨어 개발 비용이 증가
  - 처리 비용이 증가
  - 잠재적 오류가 증가



### 분산 데이터베이스 설계

: 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근한게 하는 것을 목적으로 한다.

- 잘못 설계된 분산 데이터베이스는 복잡성 증가, 응답 속도 저하, 비용 증가 등의 문제가 발생
- 전역 관계망을 논릴적 측면에서 소규모 단위로 분할 한 후, 분할된 결과를 복수의 노드에 할당하는 과정으로 진행된다. 노드에 할당된 소규모 단위를 분할이라 부른다.
- 분산 설계 방법에는 테이블 위치 분산, 분할, 할당이 있다.



### 테이블 위치 분산

: 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법을 의미

- 테이블의 구조를 변경하지 않으며, 다른 데이터베이스의 테이블과 중복되지 않게 배치한다.
- 각각 다른 위치에 배치하려면 해당 테이블들이 놓일 서버들을 미리 설정해야 한다.



### 분할(Fragment)

: 테이블의 데이터를 분할하여 분산시키는 것

- <b>분할 규칙</b>

  - 완전성(Completeness)

    : 전체 데이틀 대상으로 분할해야 한다,

  - 재구성(Reconstruction)

    : 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성할 수 있어야 한다.

  - 상호 중첩 배제(Dis-jointness)

    : 분할된 데이터는 서로 다른 분할의 항목에 속하지 않아야 한다,

- 주요 분할 방법

  - 수평 분할 : 특정 속성의 값을 기준으로 행 단위로 분할
  - 수직 분할 : 데이터 컬럼(속성) 단위로 분할



### 할당(Allocation)

: 동일한 분할을 여러 개의 서버에 생성하는 분산 방법으로, 중복이 없는 할당과 중복이 있는 할당으로 나뉜다.

- 비중복 할당 방식

  - 최적의 노드를 선택해서 분산 데이터베이스의 단일 노드에서만 분할이 존재하도록 하는 방식
  - 일반적으로 애플리케이션에는 릴레이션을 배타적 분할로 분리하기 힘든 요구가 포함되므로 분할된 테이블 간의 의존성은 무시되고, 비용 증가, 성능 저하 등의 문제가 발생한다.

- <b>중복 할당 방식</b>

  : 동일한 테이블을 다른 서버에 복제하는 방식으로, 일부만 복제하는 부분 복제와 전체를 복제하는 완전 복제가 있다.



## 94) 데이터베이스 이중화 / 서버 크러스터링(B)

### 데이터베이스 이중화(Database Replication)

: 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것이다.

- 하나 이상의 데이터베이스가 항상 같은 상태를 유지하므로 데이터베이스에 문제가 발생하면 복제된 데이터베이스를 이용하여 즉시 문제를 해결할 수 있다.
- 여러 개의 데이터베이스를 동시에 관리하므로 사용자가 수행하는 작업이 데이터베이스 이중화 시스템에 연결된 다른 데이터베이스에도 동일하게 적용
- 애플리케이션을 여러 개의 데이터베이스로 분산시켜 처리하므로 데이터베이스의 부하를 줄일 수 있다,
- 손쉽게 백업 서버를 운영할 수 있다.
- MySQL의 이중화 방식
  - 동일한 데이터베이스를 복제하여 관리하되, 데이터를 읽고 쓸 수 있는 마스터 DB와 읽기만 가능한 슬레이브 DB로 구분하여 사용
  - 슬레이브 DB는 마스터 DB의 로그를 이용하여 변경된 데이터를 동기화



### 데이터베이스 이중화의 분류

: 변경 내용의 전달방식에 따라 Eager 기법과 Lazy 기법으로 나뉜다,

- Eager 기법
  - 트랜잭션 수행 중 데이터 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법
- Lazy 기법
  - 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법으로, 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주된다.



### 데이터베이스 이중화 구성 방법

: 활동-대기(Active-Stadby) 방법과 활동-활동(Active-Active) 방법이 있다.

- 활동-대기 방법
  - 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 DB에 장애가 발생하면 대기상태에 있던 DB가 자동으로 모든 서비스를 대신 수행한다.
  - 구성 방법과 관리가 쉬워 많은 기업에서 이용
- 활동-활동 방법
  - 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공
  - 두 DB가 모두 처리르 ㄹ하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡하다.



### 클러스터링(Clustering)

: 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술

- 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공

- 고가용성 클러스터링과 병렬 처리 클러스터링이 있다.

  - 고가용성 클러스터링

     : 하나의 서버에 장애가 발생하면 다른 노드(서버)가 받아 처리하여 서비스 중단을 방지하는 방식으로, 일반적으로 언급되는 클러스터링이 고가용성 클러스터링이다.

  - 병렬 처리 클러스터링

    : 전체 처리율을 높이기 위해 하나의 작업을 여러개의 서버에서 분산하여 처리하는 방식, 사용자의 요청을 로드밸런서(Load Balancer)가 여러 대의 서버로 분산



## 95) 데이터베이스 보안 / 암호화 (B)









