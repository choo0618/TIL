# 1. 논리 데이터 베이스 설계

## 70) 데이터베이스 설계(A)

### 데이터베이스 설계의 개념

: 사용자의 요구를 분석하여 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후 특정 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것



### 데이터베이스 설계 시 고려사항

- <b>무결성</b>

  : 삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 한다.

- <b>일관성</b>

  : 데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 한다.

- <b>회복</b>

  : 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 한다.

- <b>보안</b>

  : 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 한다.

- <b>효율성</b>

  : 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 한다.

- <b>데이터베이스 확장</b>

  : 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 한다.



### 데이터베이스 설계 순서

1. 요구 조건 분석

   : 요구 조건 명세서 작성

2. 개념적 설계

   : 개념 스키마, 트랜잭션 모델링, E-R 모델

3. 논리적 설계

   : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계

4. 물리적 설계

   : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환

5. 구현

   : 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성



### 요구 조건 분석

: 데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것

- 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리형태, 흐름, 제약 조건 등을 수집
- 수집된 정보를 바탕으로 요구 조건 명세를 작성



### 개념적 설계(정보 모델링, 개념화)

: 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정

- 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
- 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성
- DBMS에 독립적인 개념 스키마를 설계



### 논리적 설계(데이터 모델링)

: 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정

- 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화
- 개념적 설계가 개념 스키마를 설계하는 단계라면 논리적 설계에서는 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
- 트랜잭션의 인터페이스를 설계
- 관계형 데이터베이스라면 테이블을 설계하는 단계



### 물리적 설계(데이터 구조화)

: 논리적 설계 단계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정

- 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액새스 경로를 결정
- 저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사



### 데이터베이스 구현

: 논리적 설계 단계와 물리적 설계 단계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정

- 사용하려는 DBMS의 DDL(데이터 정의어)을 이용하여 데이터베이스 스키마를 기술한 후 컴파일하여 빈 데이터베이스 파일을 생성
- 생성된 빈 데이터 베이스 파일에 데이터를 입력
- 응용 프로그램을 위한 트랜잭션을 작성
- 데이터베이스 접근을 위한 응용 프로그램 작성



## 71) 데이터 모델의 개념(B)

### 데이터 모델의 정의

: 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형

- 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들의 모임

- 현실세계를 데이터베이스에 표현하는 중간과정, 즉 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 사용되는 지능적 도구

- <b>데이터 모델 구성 요소</b>

  : 개체, 속성, 관계

- <b>데이터 모델 종류</b>

  : 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델

- <b>데이터 모델에 표시할 요소</b>

  : 구조, 연산, 제약 조건



### 데이터 모델의 구성 요소

- <b>개체(Entity)</b>

  : 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실세계의 대상체

- <b>속성(Attribute)</b>

  : 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당

- <b>관계(Relationship)</b>

  : 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미



### 개념적 데이터 모델

: 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정

- 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현
- 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보구조로 표현하기 때문에 정보 모델이라고도 한다.
- 대표적인 개념적 데이터 모델로는 E-R 모델이 있다.



### 논리적 데이터 모델

: 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정

- 필드로 기술된 데이터 타입과, 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현
- 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미
- 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용
- 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분



### 논리적 데이터 모델의 품질 검증

: 완성된 논리적 데이터 모델이 기업에 적합한지를 확인하기 위해 품질을 검증하는 것

- 논리 데이터 모델 품질 기준에 따라 개체, 속성, 관계, 식별자, 모델 전반 등에 대하여 검토 체크리스트를 작성하고 체크리스트의 각 항목을 확인하는 방식으로 검증
- <b>개체 품질 검증 항목</b>
- <b>속성 품질 검증 항목</b>
- <b>관계 품질 검증 항목</b>
- <b>식별자 품질 검증 항목</b>
- <b>전반적인 품질 검증 항목</b>



### 데이터 모델에 표시할 요소

- <b>구조(Structure)</b>

  : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현

- <b>연산(Operation)</b>

  : 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구

- <b>제약 조건(Constraint)</b>

  : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건



## 72) 데이터 모델의 구성 요소 - 개체(Entity) (A)

### 개체의 정의 및 특징

:  개체는 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체이다.

- 실세계에 독립적으로 존재하는 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성
- 파일 시스템의 레코드에 대응하는 것으로 어떤 정보를 제공하는 역할을 수행
- 영속적(Persistence)으로 존재하는 개체의 집합
- 독립적으로 존재하거나 그 자체로도 구별이 가능
- 유일한 식별자(Unique Identifier)에 의해 식별이 가능
- 업무나 프로세스에 의해 이용
- 다른 개체와 하나 이상의 관계(Relationship)가 있다.

| 교수번호 | 성명   | 전공   | 소속   |
| -------- | ------ | ------ | ------ |
| 144001   | 조성진 | 곤충   | 안산대 |
| 145002   | 박윤영 | 미생물 | 강원대 |
| 146001   | 강현준 | 식물   | 서울대 |

#### 교수 개체의 구성 요소

- 속성 : 개체가 가지고 있는 특성, 교수번호, 성명, 전공 소속
- 개체 타입 : 속성으로만 기술된 개체의 정의
- 개체 인스턴스 : 개체를 구성하고 있는 각 속성들이 값을 가져 하나의 개체를 나타내는것으로 개체 어커런스라고도 한다
- 개체 세트 : 개체 인스턴스의 집합



### 개체 선정 방법

- 업무 분석에 관한 내용을 구체적으로 설명한 업무 기술서를 이용
- 실제 업무를 담당하고 있는 담당자와 인터뷰
- 실제 업무를 직접 견학하여 확인
- 실제 업무에 사용되고 있는 장부와 전표를 이용
- 이미 구축된 시스템이 있는 경우 해당 시스템의 산출물을 검토
- 자료 흐름도(DFD)를 통해 업무 분석을 수행했을 경우 자료 흐름도의 자료 저장소(Data Store)를 이용
- BPR(업무 프로세스 재설계)에 의해 업무를 재정의한 경우 관련 개체를 찾는다



### 개체명 지정 방법

- 일반적으로 사용하는 용어로 지정
- 약어 사용은 되도록 제한
- 가능하면 단수 명사 사용
- 모든 개체명은 유일
- 개체가 생성되는 의미에 따라 이름 부여



## 73) 데이터 모델의 구성 요소 - 속성(Attribute)

### 속성의 정의 및 특징

- 데이터베이스를 구성하는 가장 작은 논리적 단위
- 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
- 개체를 구성하는 항목
- 개체의 특성을 기술
- 속성의 수를 디그리(Degree) 또는 차수라고 한다.



### 속성의 종류

: 속성은 속성의 특성과 개체 구성 방식에 따라 분류 가능

#### 속성의 특성에 따른 분류

- 기본 속성(Basic Attribute)

  - 업무 분석을 통해 정의한 속성
  - 속성 중 가장 많고 일반적
  - 업무로부터 분석한 속성이라도 업무상 코드로 정의한 속성은 기본 속성에서 제외

  ex) 자동차명, 제조일, 연비

- 설계 속성(Designed Attribute)

  - 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성
  - 업무에 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하려고 속성을 새로 만들거나 변형하여 정의하는 속성

  ex) 자동차 코드

- 파생 속성(Derived Attribute)

  - 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성
  - 파생 속성은 되도록 적은 수를 정의하는 것이 좋다

  ex) 계산값

#### 개체 구성 방식에 따른 분류

- 기본키 속성(Primary Key Attribute)

  : 개체를 식별할 수 있는 속성

- 외래키 속성(Foreign Key Attribute)

  : 다른 개체와의 관계에서 포함된 속성

- 일반 속성

  : 개체에 포함되어 있고 기본키, 외래키에 포함되지 않은 속성



### 속성 후보 선정 원칙

: 속성으로 지정될 후보는 최대한 많이 선택하는 것이 좋다.

- 원시(Source)속성으로 판단되는 속성 후보는 버리지 않는다.
- 소그룹벼로 속성 후보군을 만들고 가장 근접한 개체에 할당한다.



### 속석명 지정 원칙

- 속성명은 웹이나 클라이언트/서버 등 어떠한 환경에서든 사용자 인터페이스에 나타나기 때문에 정확하고 혼란이 없어야 한다.
- 속성명 지정 원칙
  - 해당 업무에서 사용하는 용어로 지정
  - 서술형으로 지정하지 않는다.
  - 가급적이면 약어 사용은 제한
  - 개체명은 속성명으로 사용할 수 없다.
  - 개체에서 유일하게 식별 가능하도록 지정



## 74) 데이터 모델의 구성 요소 - 관계(Relationship) (B)

### 관계의 정의

: 개체와 개체 사이의 논리적인 연결을 의미

- 관계에는 개체 간의 관계와 속성 간의 관계가 있다.



### 관계의 형태

: 일 대 일(1:1), 일 대 다(1:N), 다 대 다(N:M) 관계가 있다.

- <b>일 대 일(1:1)</b>

  : 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계

- <b>일 대 다(1:N)</b>

  : 개체 집합 A의 원소는 개체 집합 B의 원소 여러 개와 대응하고 있지만, 개체 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계

- <b>다 대 다(N:M)</b>

  : 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고, 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계



### 관계의 종류

: 관계는 처리하는 업무 형태에 따라 종속 관계, 중복 관계, 재귀 관계, 배타 관계 등이 있다.

- <b>종속 관계(Dependent Relationship)</b>

  : 두 개체 사이의 주종관계를 표현한 것으로, 식별 관계와 비식별 관계가 있다.

  - 식별 관계(Identifying Relationship)
    - 개체 A,B 사이의 관계에서 A 개체의 기본키가 B 개체의 외래키이면서 동시에 기본키가 되는 관계
    - B 개체의 존재 여부가 A 개체의 존재 여부에 의존적인 경우에 발생
  - 비식별 관계(Non-Identifying Relationship)
    - 개체 A,B 사이의 관계에서 A 개체의 기본키가 B 개체의 비기본키 영역에서 외래키가 되는 관계
    - B 개체의 존재 여부는 A 개체의 존재 여부와 관계없이 존재
    - 일반적으로 두 개체는 비식별 관계로 존재하는 경우가 많다
    - ER 도형에서 비식별 관계는 점선으로 표시

- <b>중복 관계(Redundant Relationship)</b>

  : 두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계

- <b>재귀 관계(Recursive Relationship)</b>

  : 개체가 자기 자신과 관계를 갖는 것으로, 순환관계라고도 한다

- <b>배타 관계(Exclusive Relationship)</b>

  - 개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계로, 배타 AND 관계와 배타 OR 관계로 구분
  - 배타 AND 관계는 하위 개체들 중 속성이나 구분자 조건에 따라 하나의 개체만을 선택할 수 있고, 배타 OR 관계는 하나이상의 개체를 선택할 수 있다.



## 75) 식별자(Identifier)

### 식별자의 정의 및 분류

: 식별자는 하나의 개체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자로, 모든 개체는 한 개 이상의 식별자를 반드시 가져야 한다.

- 개체 내에서 대표성 여부, 스스로 생성 여부, 단일 속성 여부, 대체 여부에 따라 분류

  | 분류             | 식별자                   |
  | ---------------- | ------------------------ |
  | 대표성 여부      | 주 식별자, 보조 식별자   |
  | 스스로 생성 여부 | 내부 식별자, 외부 식별자 |
  | 단일 속성 여부   | 단일 식별자, 복합 식별자 |
  | 대체 여부        | 원조 식별자, 대리 식별자 |



### 주 식별자/보조 식별자

- 주 식별자는 개체를 대표하는 유일한 식별자

- 보조 식별자는 주 식별자를 대신하여 개체를 식별할 수 있는 속성

- 두 식별자 모두 개체를 유일하게 식별할 수 있어야 한다.

- 하나의 개체에 주 식별자는 한 개만 존재하지만, 보조 식별자는 한 개 이상 존재

- 개체를 유일하게 식별할 수 있는 속성이 두 개 이상의 경우 업무에 가장 적합한 속성을 주식별자로 지정하고, 나머지는 보조 식별자로 지정

- 물리적 테이블에서 주 식별자는 기본키로, 보조 식별자는 유니크 인덱스(속성값에서 중복 값이 없도록 하는 인덱스)로 지정

- 주 식별자의 4가지 특성

  | 특징   | 설명                                                         |
  | ------ | ------------------------------------------------------------ |
  | 유일성 | - 주 식별자에 의해 개체 내에 모든 인스턴스들이 유일하게 구되어야 한다. |
  | 최소성 | - 주 식별자를 구성하는 속성의 수는 유일성을 만족하는 최소 수가 되어야 한다. |
  | 불변성 | - 주 식별자가 한 번 특정 개체에 지정되면 그 식별자는 변하지 않아야 한다. |
  | 존재성 | - 주 식별자가 지정되면 식별자 속성에 반드시 데이터 값이 존재해야 한다. |



### 내부/외부 식별자

- 내부 식별자는 개체 내에서 스스로 만들어지는 식별자이다.
- 외부 식별자는 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용하는 식별자이다.
- 외부 식별자는 자신의 개체에서 다른 개체를 찾아가는 연결자 역할을 한다.



### 단일/복합 식별자

- 단일 식별자는 주 식별자가 한가지 속성만으로만 구성된 식별자이다.
- 복합 식별자는 주 식별자가 두 개 이상의 속성으로 구성된 식별자이다.



### 원조/대리 식별자

- 원조 식벼자는 업무에 의해 만들어지는 가공되지 않은 원래의 식별자로, 본질 식별자라고도 한다.
- 대리 식별자는 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자로, 인조 식별자라고도 한다.
- 대리 식별자의 조건
  - 최대한 범용적인 값을 사용한다.
  - 유일한 값을 만들기 위한 대리 식별자를 사용할 수 없다.
  - 하나의 대리 식별자 속성으로 대체할 수 없는 경우를 주의
  - 편의성과 단순성, 의미의 체계화를 위한 대리 식별자를 사용할 수 있다.
  - 시스템적인 필요성에 의해 내부적으로만 사용하는 대리 식별자를 사용할 수 있다.



### 후보 식별자

: 개체에서 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성 집합을 의미

- 하나의 개체에는 한 개 이상의 후보 식별자가 있고, 이 중 개체의 대표성을 나타내는 식별자를 주 식별자, 나머지는 보조 식별자로 지정
- 후보 식별자의 조건
  - 각 인스턴스를 유일하게 식별할 수 있어야 한다.
  - 속성들을 직접 식별할 수 있어야 한다.
  - 널 값(NULL Value)이 될 수 없다.
  - 속성 집합은 후보 식벼자로 지정한 경우 개념적으로 유일해야 한다.
  - 후보 식별자의 데이터는 자주 변경되지 않아야 한다.



## 76) E-R(개체-관계) 모델(A)

### E-R(Entity-Relationship, 개체-관계) 모델의 개요

- E-R 모델은 개체와 개체 간의 관계를 기본 요소로 이용하여 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법으로 많이 사용되고 있다.
- 개체 타입과 이들간의 관계 타입을 이용해 현실 세계를 개념점으로 표현
- 데이터를 개체, 관계, 속성으로 묘사
- 특정 DBMS를 고려한 것은 아님
- E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있다.
- 최초에는 개체, 관계, 속성과 같은 개념들로 구성되었으나 나중에는 일반화 계층같은 복잡한 개념들이 첨가되어 확장된 모델로 발전



### E-R 다이어 그램

: E-R 모델의 기본 아이디어를 이해하기 쉽게 기호를 사용하여 시각적으로 표현한 그림

- 실체 간의 관계는 물론 조직, 사용자, 프로그램, 데이터 등 시스템 내에서 역할을 가진 모든 실체들을 표현
- 데이터에 대해 개발자, 관리자, 사용자들이 서로 다르게 인식하고 있는 뷰(View)들을 하나로 단일화
- 표기법에는 피터 첸 표기법, 정보 공학 표기법, 바커 표기법 등이 있다.



### 피터 첸 표기법

- 개체, 속성, 기본키 속성, 관계등을 다음과 같이 표현

  | 기호 이름 | 의미                                                         |
  | --------- | ------------------------------------------------------------ |
  | 사각형    | - 개체 타입                                                  |
  | 마름모    | - 관계 타입                                                  |
  | 타원      | - 속성                                                       |
  | 이중 타원 | - 다중값 속성(복합 속성)                                     |
  | 밑출 타원 | - 기본키 속성                                                |
  | 복수 타원 | - 복합 속성                                                  |
  | 관계      | - 1:1, 1:N, N:M 등의 개체 간 관계에 대한 대응수를 선 위에 기술 |
  | 선, 링크  | - 개체 타입과 속성을 연결                                    |



### 정보 공학 표기법(Information Engineering Notation)

- 개체, 속성, 기본키 속성, 관계 등을 다음과 같이 표현

  - 개체는 사각형 박스로 표시하고 개체명은 박스 바깥쪽 위에 표시
  - 속성은 기본키 속성과 일반 속성을 분리하여 표시
  - 관계는 관계 표기 기소를 사용하여 표기

- 관계 기호

  | 기호 | 의미             |
  | ---- | ---------------- |
  | ㅣ   | 필수(Mandatory)  |
  | O    | 선택적(Optional) |
  | <    | 다중(Multiple)   |



### 바커 표기법(Barker Notation)

- 개체, 속성, 기본키 속성, 관계 등을 다음과 같이 표현

  - 개체는 모서리가 둥근 박스로 표시하고 개체명은 박스 안 가장 위에 표시
  - 속성은 반드시 값이 저장되어야 하는 경우를 *를 표시하고, 값이 저장될 수도, 안될 수도 있는 경우 O를 표시
  - 관계는 관계 표시 기호를 사용하여 표시한 후 해당 개체의 역할을 동사적 단어로 입력

- 관계 표기 기소

  | 기호 | 의미   |
  | ---- | ------ |
  | 실선 | 필수   |
  | 점선 | 선택적 |
  | <    | 다중   |



## 77) 관계형 데이터 모델(C)

: 가장 널리 사용되는 데이터 모델로, 2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 DB 구조

- 파일 구조처럼 구성한 테이블들을 하나의 DB로 묶어서 테이블 내에 있는 속성들간의 관계를 설정하거나 테이블 간의 관계를 설정하여 이용
- 기본키와 이를 참조하는 외래키로 데이터 간의 관계를 표현
- 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
- 관계형 모델의 대표적인 언어는 SQL이다.
- 1:1, 1:N, N:M 관계를 자유롭게 표현할 수 있다.



## 78) 관계형 데이터베이스의 구조(A)

### 관계형 데이터베이스의 개요

- 관계형 데이터베이스를 구성하는 개체나 관계를 모두 릴레이션이라는 표로 표현

- 릴레이션은 개체를 표현하는 개체 릴레이션, 관계를 나타내는 관계릴레이션으로 구분할 수 있다.

- <b>장점</b>

  : 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이

- <b>단점</b>

  : 성능이 다소 떨어진다.



### 관계형 데이터베이스의 Relation 구조

: 릴레이션 데이터들은 표의 형태로 표현한 것으로 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성

#### 튜플(Tuple)

- 릴레이션을 구성하는 각각의 행을 말한다.
- 속성의 모임으로 구성
- 파일 구조에서 레코드와 같은 의미
- 튜플의 수를 카디널리티 또는 기수, 대응수라고 한다.

#### 속성(Attribute)

- 데이터베이스를 구성하는 가장 작은 논리적 단위
- 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
- 개체의 특성을 기술
- 속성의 수를 디그리(Degree) 또는 차수라고 한다.

#### 도메인(Domain)

- 하나의 속성이 취할 수 있는 같은 타입의 원자값들의 집합
- 실제 속성 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데 이용



### 릴레이션의 특징

- 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이
- 튜플 사이에는 순서가 없다.
- 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
- 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 구성하는 값은 동일한 값이 있을 수 있다.
- 튜플은 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정
- 속성의 값은 논리적으로 더이상 쪼갤 수 없는 원자값만을 저장



## 79) 관계형 데이터베이스의 제약 조건 - 키(Key) (A)

: 제약 조건이란 데이터 베이스에 저장되는 데이터의 정확성을 보장하기 위하여 키를 이용하여 입력되는 데이터에 제한을 주는 것으로 개체 무결성 제약, 참조 무결성 제약 등이 해당된다.

### 키(Key)의 개념 및 종류

: 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 떄 튜플들을 서로 구분할 수 있는 기준이 되는 속성을 말한다.

- 키의 종류에는 후보키, 기본키, 대체키, 슈퍼키, 외래키 등이 있다.



### 후보키(Candidate Key)

: 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성

- 하나의 릴레이션내에서는 중복된 튜플들이 있을 수 없으므로 모든 릴레이션에는 반다스 하나 이상의 후보키가 존재

- 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족 시켜야 한다

  - 유일성(Unique)

    : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.

  - 최소성(Minimality)

    : 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야한다.



### 기본키(Primary Key)

: 후보키 중에서 특별히 선정된 주키로 중복된 값을 가질 수 없다.

- 특정 튜플을 유일하게 구별할 수 있는 속성
- 기본키는 후보키의 성질을 갖는다. 유일성과 최소성을 가지며 튜플을 식별하기 위해 반드시 필요한 키이다.
- NULL 값을 가질 수 없다. 즉 튜플에서 기본키로 설정된 속성에는 NULL값이 있어서는 안된다.



### 대체키(Alternate Key) - 보조키

: 후보키가 둘 이상일때 기본키를 제외한 나머지 후보키를 의미



### 슈퍼키(Super Key)

: 한 릴레이션 내에 있는 <b>속성들의 집합으로 구성된 키</b>로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.

- 릴레이션을 구성하는 모든 튜플에 대해 유일성을 만족시키지만, 최소성은 만족시키지 못한다.



### 외래키(Foreign Key)

: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미

- 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구
- 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 한다.
- 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.



## 80) 관계형 데이터베이스의 제약 조건 - 무결성(B)

### 무결성(Integrity)의 개념 및 종류

: 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미

- 데이터베이스에 들어 있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위한 제약 조건을 말한다.
- 무결성의 종류에는 개체 무결성, 도메인 무결성, 참조 무결성, 사용자 정의 무결성 등이 있다.



### 개체 무결성(Entity Integrity, 실체 무결성)

: 기본 테이블의 기본키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다는 규정



### 도메인 무결성(Domain Integrity, 영역 무결성)

: 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정



### 참조 무결성(Referential Integrity)

: 외래키값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정



### 사용자 정의 무결성

: 속성 값들이 사용자가 정의한 제약조건에 만족해야 한다는 규정



### 데이터 무결성 강화

: 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 한다.

- 프로그램이 완성되고 데이터가 저장된 상태에서 무결성을 정의할 경우 많은 비용이 발생하므로 데이터베이스 구축 과정에서 정의
- 애플리케이션, 데이터베이스 트리거, 제약조건을 이용하여 강화할 수 있다.

#### 애플리케이션

- 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가

- 데이터베이스에서는 데이터 무결성 제약을 정의할 수 없으므로 복잡한 규칙 등은 애플리케이션 내에서 처리

- <b>장점</b>

  : 사용자 정의 같은 복잡한 무결성 조건의 구현이 가능

- <b>단점</b>

  : 소스 코드에 분산되어 있어 관리하기가 힘들고, 개별적인 시행으로 인해 적정성 검토가 어렵다

#### 데이터베이스 트리거

- 트리거

  : 데이터의 입력, 수정, 삭제 등의 이벤트가 발생할 때마다 자동적으로 수행되는 절차형 SQL

- 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가

- <b>장점</b>

  : 통합 관리가 가능하고, 복잡한 요구 조건의 구현이 가능

- <b>단점</b>

  : 운영 중 변경이 어렵고, 사용상 주의가 필요

#### 제약 조건

: 데이터베이스에 제약 조건을 설정하여 무결성 강화

- <b>장점</b>

  : 통합 관리 가능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생 방지 등

- <b>단점</b>

  : 복잡한 제약 조건의 구현과 예외적인 처리가 불가능



## 81) 관계대수 및 관계해석(A)

### 관계대수의 개요

: 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어

- 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션이고, 결과도 릴레이션이다.

- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시

- 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있다.

- <b>순수 관계 연산자</b>

  : Select, Project, Join, Division

- <b>일반 집합 연산자</b>

  : UNION(합집합), INTERESTION(교집합), DIFFERENCE(차집합), CARTESIAN PRODUCT(교차곱)



### Select

: 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산

- 행에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 한다.
- 기호는 그리스 문자 시그마를 사용
- 표기형식 : 시그마 (조건) (R)
  - R은 릴레이션 이름이다.
  - 조건에서는 =, !=, < , <=, >, >= 등의 기호를 사용한 비교 연산이 허용되며, AND, OR, NOT 등의 논리 연산자를 사용하여 여러 개의 조건들을 하나의 조건으로 결합시킬 수도 있다.



### Project

: 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산. 단 연산 결과에 중복이 발생하면 중복이 제거

- 열에 해댕하는 속성을 추출하는 것이므로 수직 연산자라고도 한다.
- 연산자의 기호는 그리스 문자 파이를 사용
- 표기형식 : 파이 (속성리스트) (R)
  - R은 릴레이션 이름이다



### Join

: 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산

- Join의 결과로 만들어진 릴레이션의 차수는 조인된 두 릴레이션의 차수를 합한 것과 같다.

- Join의 결과는 Cartesian Product(교차곱)를 수행한 다음 Select를 수행한 것과 같다.

- 연산자의 기호는 ㅣ><ㅣ 를 사용

- 표기형식 : R l><l (키속성r=키속성s) S

  - 키 속성 r은 릴레이션 R의 속성이고, 키 속성 s는 릴레이션 S의 속성이다.

- Join 조건이 '='일 때 동일한 속성이 2번 나타난다.

- 자연 조인(Natural Join)

  : 조인 조건이 '='일 때 중복된 속성을 제거하여 같은 속성을 한번만 표현하는 방법,

  * 두 릴레이션의 속송명과 도메인이 같아야 한다.



### Division

: X ) Y 인 두개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 ㅜ제외한 속성만을 구하는 연산

- 연산자의 기호는 /(나눗셈)를 사용
- 표기 형식 : R [속성r / 속성s] S
  - 속성 r은 릴레이션 R의 속성, 속성 s는 릴레이션 S의 속성, 속성 r과 속성 s는 동일 속성값을 가지는 속성이어야 한다.



### 일반 집합 연산자

: 수학적 집합 이론에서 사용하는 연산자로서 릴레이션 연산에도 그대로 적용 가능

- 합집합, 교집합, 차집합 을 처리하기 위해서는 합병 조건을 만족해야 한다.
  - 합병 조건 : 두 릴레이션 간에 속성의 수가 같고, 대응되는 속성별로 도메인이 같아야 한다. 속성의 이름이 같아야 되는 것은 아니다.



### 관계 해석(Relational Calculus) 

: 프레디킷 해석(술어해석)을 기반

- 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용
- 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다.
- 튜플 관계해석과 도메인 관계해석이 있다.
- 기본적으로 관계해석과 관계대수는 관계 데이터 베이스를 처리하는 기능과 능력면에서 동등하며, 관계대수로 표현한 식은 관계 해석으로 표현 가능
- 질의어로 표현



## 82) 정규화(Normalization) (A)

### 정규화의 개요

: 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만드는 과정

- 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정이라 할 수 있다.
- 정규형에는 제1정규형, 제2정규형, 제3정규형, BCNF형, 제4정규형, 제5정규형이 있으며, 차수가 높아 질수록 만족시켜야 할 제약 조건이 늘어난다.
- 데이터베이스의 논리적 설계 단계에서 수행
- 논리적 처리 및 품질에 큰 영향을 미친다.
- 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안전성 등을 보장
- 수준이 높을수록 유연한 데이터 구축이 가능하고, 데이터의 정확성이 높아지는 반면 물리적 접근이 복잡하고 너무 많은 조인으로 인해 조회 성능이 저하



### 정규화의 목적

- 데이터 구조의 안전성 및 무결성을 유지
- 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다.
- 효과적인 검색 알고리즘을 생성 가능
- 데이터 중복을 배제하여 이상의 발생 방지 및 자료 저장 공간의 최소화가 가능
- 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
- 데이터 모형의 단순화가 가능
- 속성의 배열 상태 검증이 가능
- 개체와 속성의 누락 여부 확인이 가능
- 자료 검색과 추출의 효율성을 추구



### 이상(Anomaly)의 개념 및 종류

: 정규화를 거치지 않으면 데이터베이스 내에 데이터들이 불필요하게 <b>중복</b>되어 릴레이션 조작 시 예기치 못한 곤란한 현상이 발생하는데, 이를 이상(Anomaly)이라 하며 삽입 이상, 삭제 이상, 갱신 이상이 있다.

- <b>삽입 이상(Insertion Anomaly)</b>

  : 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상

- <b>삭제 이상(Delete Anomaly)</b>

  : 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상

- <b>갱신 이상(Update Anomaly)</b>

  : 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상



### 정규화의 원칙

- 정보의 무손실 표현, 즉 하나의 스키마를 다른 스키마로 변환할 떄 정보의 손실이 있어서는 안 된다.
- 분리의 원칙, 즉 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.
- 데이터의 중복성이 감소되어야 한다.



### 정규화 과정

#### 1NF(제1정규화)

: 릴레이션에 속한 모든 도메인이 원자값만으로 되어 있는 정규형이다. 즉, 릴레이션의 모든 속성 값이 원자 값으로만 되어 있는 정규형이다.

- 릴레이션의 모든 속성이 단순 영역에서 정의된다.

#### 2NF(제2정규화)

: 릴레이션 R이 1NF이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형이다.

- 함수적 종석/ 완전/부분 함수적 종속 및 이해

  - 함수적 종속(Functional Dependency)

    - 데이터들이 어떤 기준값에 의해 종속되는 것을 의미

  - 완전 함수적 종속

    - 어떤 테이블 R에서 속성 A가 다른 속성 집합 B 전체에 대해 함수적 종속이지만 속성 집합 B의 어떠한 진 부분 집합 C에는 함수적 종속이 아닐 때 속성 A는 속성 집합 B에 완전 함수적 종속이라 한다.

  - 부분 함수적 종속

    - 어떤 테이블 R에서 속성 A가 다른 속성 집합 B 전체에 대해 함수적 종속이면서 속성 집합 B의 어떠한 진 부분 집합에도 함수적 종속일 때, 속성 A는 속성 집합 B에 부분 함수적 종속이라 한다.

  - 완전/부분 함수적 종속의 이해

    - 완전 함수적 종속은 어떤 속성이 기본키에 대해 완전히 종속일 때를 말한다

    ex) 수강 릴레이션에서 (학번, 과목명)이 기본키 일때, 학번과 과목명이 같을 경우 항상 같은 '성적'이 온다. 이때 성적은 기본키 (학번, 과목명)에 완전 함수적 종속이 된다.

    반면에 '학년'은 과목명에 관계없이 학번이 같으면 항상 같은 학년이 온다. 즉 기본키으 일부에 의해서 결정이 될때 부분 함수적 종속이라 한다.

#### 3NF(제3정규형)

: 릴레이션 R이 2NF이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적종속을 만족하지 않는 정규형이다.

- 이행적 종속 : A>B이고 B>C일때 A>C를 만족한는 관계를 의미
- 무손실 조인 또는 종속성 보존을 저해하지 않고도 항상 3NF 설계를 얻을 수 있다.



#### BCNF(Boyce-Codd 정규형)

: 릴레이션 R에서 결정자가 모두 후보키인 정규형

- 결정자/종속자 : 결정자는 종속성을 규명할 때 기준이되는 값이고, 종속자는 결정자의 값에 의해 정해지는 값을 의미
- 3NF에서 후보키가 여러 개 존재하고 서로 중첩되는 경우에 적용하는, 강한 제3정규형이라고도 한다.
- 모든 BCNF가 종속성을 보존하는 것은 아니다.
- BCNF의 제약 조건
  - 키가 아닌 모든 속성은 각 키에 대하여 완전 종속해야 한다.
  - 키가 아닌 모든 속성은 그 자신이 부분적으로 들어가 있지 않은 모든 키에 대하여 완전 종속해야 한다.
  - 어떤 속성도 키가 아닌 속성에 대해서는 완전 종속할 수 없다.



#### 4NF(제4정규형)

: 릴레이션 R에 다치 종속 A>>B가 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형이다.

- 다치 종속 : A, B, C  3개의 속성을 가진 릴레이션 R에서 어떤 복합 속성(A, C)에 대응하는 B 값의 집합이 A에만 종속되고 C값에는 무관하면 B는 A에 다치 종속이라 한다.



#### 5NF(제5정규형, PJ/NF)

: 릴레이션 R의 모든 조인 속성이 R의 후보키를 통해서만 성립되는 정규형이다.

- 조인 종속 : 부분 집합을 모두 조인한 결과가 자신과 동일한 경우 릴레이션 R은 조인 속성을 만족한다고 한다.



#### 정규화 과정 정리

비정규 릴레이션 >> (도메인 원자값) >> 1NF >> (부분적 함수 종속 제거) >> 2NF >> (이행적 함수 종속 제거) >> 3NF >>

(이행적 함수 종속 제거) >> BCNF >> (다치 종속) >> 4NF >> (조인 종속성 이용) >> 5NF

- 암기 요령
  - 두부이걸다줘? = 도부이결다조
  - 도(메인 원자값)부(분적 함수 종속 제거)이(행적 함수 종속 제거)결(정자이면서 후보키가 아닌 것 제거)다(치종속)조(인종속성 이용)



## 83) 반정규화(Denormalization) (B)

### 반정규화의 개념

: 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위

- 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다.
- 과도한 반정규화는 성능을 저하시킬 수 있다.
- 반정규화를 위해서는 사전에 데이터의 일관성과 무결성을 우선으로 할지, 데이터베이스의 성능과 단순화를 우선으로 할지 결정해야 한다,
- 반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가 등이 있다.



### 테이블 통합

: 두 개의 테이블이 조인되는 겨우가 많아 하나의 데이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행

- 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우, 두 개의 테이블을 이용하여 항상 조회를 수행하는 경우 테이블 통합을 고려
- 1:1 관계 테이블 통합, 1:N 관계 테이블 통합, 슈퍼타입/서브타입 테이블 통합이 있다.
- 테이블 통합 시 고려사항
  - 데이터 검색은 간편하지만 레코드 증가로 인해 처리량이 증가
  - 테이블 통합으로 인해 입력, 수정, 삭제 규칙이 복잡해질 수 있다.
  - Not Null, Default, Check 등의 제약조건을 설계하기 어렵다.



### 테이블 분할

: 테이블 분할은 테이블을 수직 또는 수평으로 분할 하는 것이다.

- 수평 분할(horizontal Partitioning)

  - 레코드를 기준으로 테이블을 분할
  - 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할

- 수직 분할(Vertical Partitioning)

  - 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할

  - <b>갱신 위주의 속성 분할</b>

    : 데이터 갱신 시 레코드 잠금으로 인해 다른 작업을 수행할 수 없으므로 갱신이 자주 일어나는 속성들을 수직 분할하여 사용

  - <b>자주 조회되는 속성 분할</b>

    : 자주 조회되는 속성이 극히 일부일 경우 속성들을 수직 분할하여 사용

  - <b>크기가 큰 속성 분할</b>

    : 이미지나 2GB 이상 저장될 수 있는 텍스트 형식 등으로 된 속성들을 수직 분할하여 사용

  - <b>보안을 적용해야 하는 속성 분할</b>

    : 테이블 내의 특정 속성에 대해 보안을 적용할 수 없으므로 보안으 ㄹ적용해야 하는 속성들은 수직 분할하여 사용

- 테이블 분할 시 고려 사항

  - 기본키의 유일성 관리가 어려워진다.
  - 데이터 양이 적거나 사용 빈도가 낮은 경우 분할이 필요한지를 고려
  - 분할된 테이블로 인해 수행 속도가 느려질 수 있다.
  - 데이터 검색에 중점을 두어 테이블 분할 여부를 결정



### 중복 테이블 추가

: 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 작업의 효율성을 향상시킬 수 있다.

- 중복 테이블을 추가하는 경우

  - 정규화로 인해 수행 속도가 느려지는 경우
  - 많은 범위의 데이터를 자주 처리해야 하는 경우
  - 특정 범위의 데이터만 자주 처리해야 하는 경우
  - 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우

- 중복 테이블을 추가하는 방법

  - <b>집계 테이블의 추가</b>

    : 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것으로, 트리거의 오버헤드에 유의 해야한다.

  - <b>진행 테이블의 추가</b>

    : 이력 관리 등의 목적으로 추가하는 테이블로, 적절한 데이터 양의 유지와 활용도를 높이기 위해 기본키를 적절히 설정

  - <b>특정 부분만을 포함하는 테이블 추가</b>

    : 데이터가 많은 테이블이 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블 생성



### 중복 속성 추가

: 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나로 더 추가하는 것이다.

- 데이터의 무결성 확보가 어렵고, 디스크 공간이 추가로 필요
- 중복 속성을 추가하는 경우
  - 조인이 자주 발생하는 속성인 경우
  - 접근 경로가 복잡한 속성인 경우
  - 액세스의 조건으로 자주 사용되는 속성인 경우
  - 기본키의 형태가 적절하지 않거나 여러개의 속성으로 구성된 경우
- 중복 속성 추가 시 고려 사항
  - 테이블 중복과 속성의 중복을 고려
  - 데이터 일관성 및 무결성에 유의
  - SQL 그룹 함수를 이용하여 처리할 수 있어야 한다.
  - 저장 공간의 지나친 낭비를 고려



## 84) 시스템 카탈로그(A)

### 시스템 카탈로그(System Catalog)의 의미

: 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다.

- 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다.
- 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 한다.



### 시스템 카탈로그 저장 정보

: 시스템 카탈로그에 저장된 정보를 메가 데이터(Mega-Data)라고 한다.

- <b>메가 데이터의 유형</b>

  - 데이터베이스 객체 정보

    : 테이블, 인덱스, 뷰, 등의 구조 및 통계 정보

  - 사용자 정보

    : 아이디, 패스워드, 접근 권한 등

  - 테이블의 무결성 제약 조건 정보

    : 기본키, 외래키, Null 값 허용 여부 등

  - 함수, 프로시저, 트리거 등에 대한 정보



### 카탈로그의 특징

- 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여 내용을 검색해 볼 수 있다.

- INSERT, DELETE, UPDATE문으로 카탈로그를 갱신하는 것은 허용되지 않는다.

- 데이터베이스 시스템에 따라 상이한 구조를 갖는다.

- 카탈로그는 DBMS가 스스로 생성하고 유지한다.

- <b>카탈로그의 갱신</b>

  : 사용자가 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 갱신

- <b>분산 시스템에서의 카탈로그</b>

  : 보통의 릴레이션, 인덱스, 사용자 등의 정보를 포함할 뿐 아니라 위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보를 가져야 한다.



### 카탈로그/데이터 사전을 참조하기 위한 DBMS 내의 모듈 시스템

- <b>데이터 정의어 번역기(DDL Compiler)</b>

  : DDL을 메타 데이터를 갖는 테이블로 변환하여 데이터 사전에 저장

- <b>데이터 조작어 번역기(DCL Compiler)</b>

  : 응용 프로그램에 삽입된 DML문을 주 언어로 표현한 프로시저 호출로 변환하여 질의 처리기와 상호 통신

- <b>Data Directory</b>

  - 데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템
  - 시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 데이터 디렉터리는 시스템만 접근할 수 있다.

- <b>질의 최적화기</b>

  : 사용자의 요구를 효율적인 형태로 변환하고 질의를 처리하는 좋은 전략을 모색

- <b>트랜잭션 처리기</b>

  : 복수 사용자 환경에서 평행으로 동시에 일어나는 트랜잭션 문제를 해결하여, 각각의 사용자가 데이터베이스 자원을 배타적으로 이용할 수 있도록 한다





















