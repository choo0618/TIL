# 4. SQL 활용

## 108) 프로시저(Procedure)(A)

### 프로시저의 개요

: 절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어로, 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업을 수행한다.

- 프로시저를 만들어 데이터베이스에 저장하면 여러 프로그램에서 호출하여 사용할 수 있다.
- 데이터베이스에 저장되어 수행되기 때문에 스토어드(Stored) 프로시저라고도 불린다.
- 시스템의 일일 마감 작업, 일괄(Batch) 작업 등에 주로 사용된다.

#### 프로시저의 구성도

- <b>DECLEAR</b>

  : 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부

- <b>BEGIN/END</b>

  : 프로시저의 시작과 종료를 의미

- <b>CONTROL</b>

  : 조건문 또는 반복문이 삽입되어 순차적으로 처리

- <b>SQL</b>

  : DML, DCL이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업을 수행

- <b>EXCEPTION</b>

  : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의

- <b>TRANSACTION</b>

  : 수행된 데이터 작업들을 DB에 적용할지 취소할지를 결정하는 처리부



### 프로시저 생성

: 프로시저를 생성하기 위해서는 CREATE PROCEDURE 명령어를 사용

#### 표기 형식

```sql
CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터)
[지역변수 선언]
BEGIN
	프로시저 BODY;
END;
```

- <b>OR REPLACE</b>

  : 선택적인 예약어이다. 이 예약어를 사용하면 동일한 프로시저 이름이 이미 존재하는 경우, 기존의 프로시저를 대체할 수 있다

- <b>프로시저명</b>

  : 생성하려는 프로시저의 이름을 지정한다.

- <b>파라미터</b>

  - IN : 호출 프로그램이 프로시저에게 값을 전달할 때 지정
  - OUT : 프로시저가 호출 프로그램에게 값을 반환할 때 지정
  - INOUT : 호출 프로그램이 프로시저에게 값을 전달하고, 프로시저 실행 후 호출 프로그램에 값을 반환 할때 지정
  - 매개변수명 : 호출 프로그램으로부터 전달받은 값을 저장할 변수의 이름을 지정
  - 자료형 : 변수의 자료형을 지정

- <b>프로시저 BODY</b>

  - 프로시저의 코드를 기록하는 부분
  - BEGIN에서 시작하여 END로 끝나며, BEGIN과 END 사이에는 적어도 하나의 SQL문이 있어야 한다.



### 프로시저 실행

: 프로시저를 실행하기 위해서는 EXECUTE 명령어 또는 CALL 명령어를 사용하며, EXECUTE 명령어를 줄여서 EXEC로 사용하기도 한다.

#### 표기 형식

```sql
EXECUTE 프로시저명;
EXEC 프로시저명;
CALL 프로시저명;
```



### 프로시저 제거

: 프로시저를 제거하기 위해서는 DROP PROCEDURE 명령어를 사용

#### 표기 형식

```sql
DROP PROCEDURE 프로시저명;
```



## 109) 트리거(Trigger) (B)

### 트리거의 개요

: 데이터베이스 시스템에서 데이터의 삽입(Insert), 갱신(Update), 삭제(Delete) 등의 이벤트(Event)가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL이다.

- 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용된다.
- 트리거의 구문에는 DCL을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류가 발생한다.
- 트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향을 미치므로 트리거를 생성할 때 세심한 주의가 필요하다.



### 트리거의 구성

: 트리거는 선언, 이벤트, 시작, 종료로 구성되며, 시작과 종료 구문 사이에는 제어(CONTROL), SQL, 예외(EXEPTION)가 포함

#### 트리거의 구성도

- <b>DECLARE</b>

  : 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의하는 선언부

- <b>EVENT</b>

  : 트리거가 실행되는 조건을 명시

- <b>BEGIN/END</b>

  : 트리거의 시작과 종료를 의미

- <b>CONTROL</b>

  : 조건문 또는 반복문이 삽입되어 순차적으로 처리

- <b>SQL</b>

  : DML문이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업을 수행

- <b>EXCEPTION</b>

  : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의



### 트리거의 생성

: 트리거를 생성하기 위해서는 CREATE TRIGGER 명령어를 사용

#### 표기 형식

```sql
CREATE [OR REPLACE] TRIGGER 트리거명 [동작시기 옵션][동작 옵션] ON
테이블명
REFERENCING [NEW | OLD] AS 테이블명
FOR EACH ROW
[WHEN 조건식]
BEGIN
		트리거 BODY;
END;
```

- <b> OR REPLACE</b>

  : 선택적인 예약어이다. 이 예약어를 사용하면 동일한 트리거 이름이 이미 존재하는 경우, 기존의 프로시저를 대체할 수 있다.

- <b>동작시기 옵션</b>

  : 트리거가 실행될 때를 지정한다. 옵션에는 AFTER와 BEFORE가 있다.

  - AFTER : 테이블이 변경된 후에 트리거가 실행
  - BEFORE : 테이블이 변경되기  전에 트리거가 실행

- <b>동작 옵션</b>

  : 트리거가 실행되게 할 작업의 종류를 지정한다. 옵션에는 INSERT, DELETE, UPDATE가 있다.

  - INSERT : 테이블에 새로운 튜플을 삽입할 때 트리거가 실행
  - DELETE : 테이블에 튜플을 삭제할 때 트리거가 실행
  - UPDATE : 테이블의 튜플을 수정할 떄 트리거가 실행

- <b>NEW | OLD</b>

  : 트리거가 적용될 테이블의 별칭을 지정

  - NEW : 추가되거나 수정에 참여할 튜플들의 집합(테이블)을 의미
  - OLD : 수정되거나 삭제 전 대상이 되는 튜플들의 집합(테이블)을 의미

- <b>FOR EACH ROW</b>

  : 각 튜플마다 트리거를 적용한다는 의미

- <b>WHEN 조건식</b>

  : 선택적인 예약어이다. 트리거를 적용할 튜플의 조건을 지정

- <b>트리거 BODY</b>

  - 트리거의 본문 코드를 입력하는 부분
  - BEGIN으로 시작해서 END로 끝나는데, 적어도 하나 이상의 SQL문이 있어야 한다. 그렇지 않으면 오류 발생



### 트리거의 제거

: 트리거를 제거하기 위해 DROP TRIGGER 명령어를 사용

#### 표기 형식

```sql
DROP TRIGGER 트리거명;
```



## 110) 사용자 정의 함수(B)

### 사용자 정의 함수의 개요

: 프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하며, 종료 시 처리 결과를 단일값으로 반환하는 절차형 SQL이다.

- 데이터베이스에 저장되어 SELECT, INSERT, DELETE, UPDATE 등 DML문의 호출에 의해 실행

- 예약어 RETURN을 통해 값을 반환하기 때문에 출력 파라미터가 없다.

- INSERT, DELETE, UPDATE를 통한 테이블 조작은 할 수 없고 SELECT를 통한 조회만 할 수 있다.

- 프로시저를 호출하여 사용할 수 없다.

- SUM(), AVG() 등의 내장 함수처럼 DML문에서 반환 값을 활용하기 위한 용도로 사용된다.

- 프로시저 VS 사용자 정의 함수

  | 구분             | 프로시저                   | 사용자 정의 함수 |
  | ---------------- | -------------------------- | ---------------- |
  | 반환값           | 없거나 1개 이상 가능       | 1개              |
  | 파라미터         | 입출력 가능                | 입력만 가능      |
  | 사용 가능 명령문 | DCL, DML                   | SELECT           |
  | 호출             | 프로시저, 사용자 정의 함수 | 사용자 정의 함수 |
  | 사용 방법        | 실행문                     | DML에 포함       |



### 사용자 정의 함수의 구성

: 프로시저와 유사하다. 프로시저의 구성에서 RETURN만 추가하면 된다.

- <b>DECLARE</b>

  : 사용자 정의 함수의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부

- <b>BEGIN/END</b>

  : 사용자 정의 함수의 시작과 종료를 의미

- <b>CONTROL</b>

  : 조건문 또는 반복문이 삽입되어 순차적으로 진행

- <b>SQL</b>

  : SELECT문이 삽입되어 데이터 조회 작업을 수행

- <b>EXCEPTION</b>

  : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의

- <b>RETURN</b>

  : 호출 프로그램에 반환할 값이나 변수를 정의



### 사용자 정의 함수 생성

: 사용자 정의 함수를 생성하기 위해서는 CREATE FUNCTION 명령어를 사용한다.

#### 표기 형식

```sql
CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터)
[지역변수 선언]
BEGIN
	사용자 정의 함수 BODY;
	RETURN 반환값;
END;
```

- <b>OR REPLACE</b>

  : 선택적인 예약어이다. 이 예약어를 사용하면 동일한 사용자 정의 함수의 이름이 이미 존재하는 경우, 기존의 사용자 정의 함수를 대체할 수 있다.

- <b>파라미터</b>

  : 사용자 정의 함수의 파라미터로는 다음과 같은 것들이 올 수 있다.

  - IN : 호출 프로그램이 사용자 정의 함수에게 값을 전달할 때 지정
  - 매개변수명 : 호출 프로그램으로부터 전달받은 값을 저장할 변수의 이름을 지정
  - 자료형 : 변수의 자료형을 지정

- <b>사용자 정의 함수 BODY</b>

  - 사용자 정의 함수의 코드를 기록하는 부분
  - BEGIN에서 시작하여 END로 끝나며, BEGIN과 END 사이에는 적어도 하나의 SQL문이 있어야 한다.

- <b>RETURN 반환값</b>

  : 반환할 값이나 반환할 값이 저장된 변수를 호출 프로그램으로 돌려준다.



### 사용자 정의 함수 실행

: 사용자 정의함수는 DML에서 속성명이나 값이 놓일 자리를 대체하여 사용된다.

#### 표기 형식

```sql
SELECT 사용자 정의 함수명 FROM 테이블명;
INSERT INTO 테이블명(속성명) VALUES (사용자 정의 함수명);
DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명;
UPDATE 테이블명 SET 속성명 = 사용자 정의 함수명;
```



### 사용자 정의 함수 제거

: 사용자 정의 함수를 제거하기 위해서는 DROP FUNCTION 명령어를 사용

#### 표기형식

```sql
DROP FUNCTION 사용자 정의 함수명;
```



## 111) DBMS 접속 기술(B)

### DBMS 접속의 개요

: 사용자가 데이터를 사용하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것을 의미

- 응용 시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달하는 매개체 역할을 수행

- 인터넷을 통해 구동되는 웹 응용 프로그램은 웹 응용 시스템을 통해 DBMS에 접근한다.

- 웹 응용 시스템은 웹 서버와 웹 애플리케이션 서버(WAS)로 구성되며, 서비스 규모가 작은 경우 웹 서버와 웹 애플리케이션 서버를 통합하여 하나의 서버만으로 운용할 수 있다.

- 웹 응용 시스템의 구조

  : 사용자 >> (웹 서버 >> WAS) >> DBMS

  ​					(웹 응용 시스템)

  - 사용자는 웹 서버에 접속하여 데이터를 주고받습니다.
  - 웹 서버는 많은 수의 서비스 요청을 처리하기 때문에 사용자가 대용량의 데이터를 요청하면 직접 처리하지 않고 WAS에게 해당 요청을 전달합니다.
  - WAS는 수신한 요청을 트랜잭션 언어로 변환한 후 DBMS에 전달하여 데이터를 받습니다. 이렇게 받은 데이터는 처음 요청한 웹 서버로 다시 전달되어 사용자에게 도달합니다.



### DBMS 접속 기술

: DBMS에 접근하기 위해 사용하는 API 또는 API의 사용을 편리하게 도와주는 프레임워크 등을 의미합니다.

### JDBC(Java DataBase Connectivity)

: Java 언어로 다양한 종류의 데이터베이스에 접속하고 SQL문을 수행할 떄 사용되는 표준 API이다

- Java SE(Standard Edition)에 포함되어 있으며, JDBC 클래스는 java, sql, javax.sql에 포함되어 있다.
- 접속하려는 DBMS에 대한 드라이버가 필요



#### ODBC(Open Database Connectivity)

: 데이터베이스에 접근하기 위한 표준 개방형 API로, 개발 언어에 관계없이 사용이 가능하다.

- 프로그램 내 ODBC 문장을 사용하여 MS-Access, Base, DB2, Excel, Text 등 다양한 데이터베이스에 접근할 수 있다.
- ODBC도 접속하려면 DBMS에 맞는 드라이버가 필요하지만, 접속하려는 DBMS의 인터페이스를 알지 못하더라도 ODBC 문장을 사용하여 SQL을 작성하면 ODBC에 포함된 드라이버 관리자가 해당 DBMS의 인터페이스에 맞게 연결해 주므로 DBMS의 종류를 몰라도 된다.



#### MyBatis

: JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈 소스 접속 프레임 워크이다.

- JDBC로 데이터베이스에 접속하려면 다양한 메소드를 호출하고 해제해야 하는데, MyBetis는 이를 간소화 했고 접속 기능을 더욱 강화하였다.
- SQL 문장을 분리하여 XML 파일을 만들고, Mapping을 통해 SQL을 실행한다.
- SQL을 거의 그대로 사용할 수 있어 SQL 친화적인 국내 환경에 적합하여 많이 사용된다.



### 동적 SQL(Dynamic SQL)

: 개발 언어에 삽입되는 SQL 코드를 문자열 변수에 넣어 처리하는 것으로, 조건에 따라 SQL 구문을 동적으로 변경하여 처리할 수 있다.

- 사용자로부터 SQL문의 일부 또는 전부를 입력받아 실행할 수 있다.

- 값이 입력되지 않을 경우 사용하는 NVL 함수를 사용할 필요가 없다.

- 응용 프로그램 수행 시 SQL이 변형될 수 있으므로 프리컴파일할때 구문 분석, 접근 권한 확인 등을 할 수 없다.

- 정적 SQL에 비해 속도가 느리지만, 상황에 따라 다양한 조건을 첨가하는 등 유연한 개발이 가능하다.

- 정적 SQL VS 동적 SQL

  |           | 정적 SQL(Static SQL)                          | 동적 SQL(Dynamic SQL)              |
  | --------- | --------------------------------------------- | ---------------------------------- |
  | SQL 구성  | 커서를 통한 정적 처리                         | 문자열 변쉐 담아 동적 처리         |
  | 개발 패턴 | 커서의 범위 안에서 반복문을 활용하여 SQL 작성 | NVL 함수 없이 로직을 통해 SQL 작성 |
  | 실행속도  | 빠르다                                        | 느리다                             |
  | 사전검사  | 가능                                          | 불가능                             |



## 112) SQL 테스트(B)

### SQL 테스트의 개요

: SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증하는 과정이다.

- 단문 SQL은 SQL 코드를 직접 실행한 후 결과를 확인하는 것으로 간단히 테스트가 가능
- 절차형 SQL은 테스트 전에 생성을 통해 구문 오류나 참조 오류의 존재 여부를 확인한다.
- 정상적으로 생성된 절차형 SQL은 디버깅을 통해 로직을 검증하고, 결과를 통해 최종적으로 확인한다.



### 단문 SQL 테스트

: DDL, DML, DCL이 포함되어 있는 SQL과 TCL을 테스트하는 것으로, 직접 실행하여 결과물을 확인한다.

- 실행 시 오류나 경고가 발생할 경우 메시지를 참조하여 문제를 해결

- DESCRIBE 명령어를 이용하면 DDL로 작성된 테이블이나 뷰의 속성, 자료형, 옵션들을 바로 확인할 수 있다.

  \- DESC [개체명]

- DML로 변경한 데이터는 SELECT문으로 데이터의 정상적인 변경 여부를 확인할 수 있다.

- DCL로 설정된 사용자 권한은 사용자 권한 정보가 저장된 테이블을 SELECT로 조회하거나, SHOW 명령어로 확인할 수 있다.

  - Oracle : SELECT * FROM DBA_ROLE_PRIVES WHERE GRANTEE = 사용자;
  - MySQL : SHOW GRATS FOR 사용자@호스트;



### 절차형 SQL 테스트

: 프로시저, 사용자 정의 함수, 트리거 등의 절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과를 확인하는 테스트를 수행한다.

- 많은 코드로 구성된 절차형 SQL의 특성상 오류 및 경고 메시지가 상세히 출력되지 않으므로 SHOW 명령어를 통해 오류 내용을 확인하고 문제를 수정
  - 형식 : SHOW ERRORS;
- 데이터베이스에 변화를 줄 수 있는 SQL문은 주석으로 처리하고, 출력문을 이용하여 화면에 출력하여 확인한다.
  - Oracle 출력 형식
    - DMBS_OUTPUT.ENABLE; : 화면에 출력하기 위해 DBMS_OUTPUT 패키지를 불러온다.
    - DBMS_OUTPUT.PUT_LINE(데이터); : '데이터'에 넣은 변수나 값을 화면에 출력한다.
  - MySQL 출력 형식
    - SELECT 데이터; : '데이터'에 넣은 변수나 값을 화면에 출력한다.
- 디버깅이 완료되면 출력문을 삭제하고, 주석 기호를 삭제한 후 절차형 SQL을 실행하여 결과를 검토한다.



## ORM(Object-Relational Mapping) (B)

### ORM의 개요

: 객체지향 프로그래밍의 객체와 관계형 데이터베이스의 데이터를 연결(Mapping)하는 기술을 의미

- 객체지향 프로그래밍에서 사용할 수 있는 가상의 객체지향 데이터베이스를 만들어 프로그래밍 코드와 데이터를 연결한다.
- 생성된 가상의 객체지향 데이터베이스는 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수가 용이하다.
- SQL 코드를 직접 입력하지 않고 선언문이나 할당 같은 부수적인 코드가 생략되기 때문에 직관적이고 간단하게 데이터를 조작할 수 있다.



### ORM 프레임 워크

: ORM을 구현하기 위한 구조와 구현을 위해 필요한 여러 기능들을 제공하는 소프트웨어를 의미

- ORM 프레임워크의 종류

  | 언어   | 프레임워크                                         |
  | ------ | -------------------------------------------------- |
  | JAVA   | JPA, hibernate, EclipseLink, DataNucleus, Ebean 등 |
  | C++    | ODB, QxOrm 등                                      |
  | Python | Django, SQLAlchemy, Storm 등                       |
  | iOS    | DatabaseObjects, Core Data 등                      |
  | .NET   | NHibernate, DatabaseObjects, Dapper 등             |
  | PHP    | Doctrine, Propel, RedBean 등                       |



### ORM의 한계

- ORM은 프레임 워크가 자동으로 SQL을 작성하기 때문에 의도대로 SQL이 작성되었는지 확인할 필요가 있다.
- 객체지향적인 사용을 고려해야 하고, 설계된 데이터베이스가 아닌 경우 프로젝트가 크고 복잡해질수록 ORM 기술을 적용하기 어려워진다.
- 기존의 기업들은 ORM을 고려하지 않은 데이터베이스를 사용하고 있기 때문에 ORM에 적합하게 변환하려면 많은 시간과 노력이 필요



## 114) 쿼리 성능 최적화(C)

### 쿼리 성능 최적화

: 데이터 입출력 애플리케이션의 성능 향사을 위해 SQL코드를 최적화하는 것이다.

- 쿼리 성능을 최적화하기 전에 성능 측정 도구인 APM을 사용하여 최적화 할 쿼리를 선정해야 한다.

- 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스를 재구성한다.

  - 옵티마이저 : 작성된 SQL이 가장 효율적으로 실행되도록 최적의 경로를 찾아주는 모듈

- RBO VS CBO

  : RBO는 규칙 기반 옵티마이저고, CBO는 비용기반 옵티마이저이다.

  |             | RBO                                 | CBO                                  |
  | ----------- | ----------------------------------- | ------------------------------------ |
  | 최적화 기준 | 규칙에 정의된 우선순위              | 액세스 비용                          |
  | 성능 기준   | 개발자의 SQL 숙련도                 | 옵티마이저의 예측 성능               |
  | 특징        | 실행 계획 예측이 쉬움               | 성능 통계치 정보 활용, 예측이 복잡함 |
  | 고려사항    | 개발자의 규칙 이해도, 규칙의 효율성 | 비용 산출 공식의 정확성              |

  

### 실행 계획(Execution Plan)

: DBMS의 옵티마이저가 수립한 SQL 코드의 실행 절차와 방법을 의미

- 실행계획은 EXPLAIN 명령어를 통해 확인할 수 있으며, 그래픽이나 텍스트로 표현된다.
- 실행 계획에는 요구사항들을 처리하기 위한 연산 순서가 적혀있으며, 연산에는 조인, 테이블 검색, 필터, 정렬 등이 있다.



### 쿼리 성능 최적화

: 실행 계획에 표시된 연산 순서, 조인 방식, 테이블 조회 방법 등을 참고하여 SQL문이 더 빠르고 효율적으로 작동하도록 SQL 코드와 인덱스를 재구성하는 것을 의미

#### SQL 코드의 재구성

- WHERE 절을 추가하여 일부 레코드만 조회하게 함으로써 조회에 들어가는 비용을 줄인다.
- WHERE 절에 연산자가 포함되면 INDEX를 활용하지 못하므로 가능한 한 연사자 사용을 자제한다.
- 서브 쿼리에 특정 데이터가 존재한는지 확인할 떄는 IN보다는 EXISTS를 활용한다.
- 옵티마이저의 실행 계획이 잘못되었다고 판단되는 경우 힌트를 활용하여 실행 계획의 액세스 경로 및 조인 순서를 변경한다.



#### 인덱스 재구성

- SQL 코드에서 조회되는 속성과 조건들을 고려하여 인덱스를 구성한다.
- 실행 계획을 참고하여 인덱스를 추가하거나 기존 인덱스의 열 순서를 변경한다.
- 인덱스의 추가 및 변경은 해당 테이블을 참조하는 다른 SQL문에도 영향을 줄 수 있으므로 신중히 결정한다.
- 단일 인덱스로 쓰기나 수정 없이 읽기로만 사용되는 테이블의 경우 IOT(Index-Organized Table)로 구성하는 것을 고려
- 불필요한 인덱스를 제거한다.

